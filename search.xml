<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>channel源码学习</title>
      <link href="/2023/08/27/channel%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/08/27/channel%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>特别提醒，本文所涉及的源码是<code>go1.21.0 darwin/amd64</code></p><p>文件位置：runtime&#x2F;trace&#x2F;chan.go</p></blockquote><h3 id="1-基本数据结构"><a href="#1-基本数据结构" class="headerlink" title="1 基本数据结构"></a>1 基本数据结构</h3><h4 id="1-1hchan"><a href="#1-1hchan" class="headerlink" title="1.1hchan"></a>1.1hchan</h4><p><code>Go</code>语言的<code>channel</code>在运行时使用<code>runtime.hchan</code>结构体来表示，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">qcount   <span class="type">uint</span>           <span class="comment">// 已经存放的元素个数</span></span><br><span class="line">dataqsiz <span class="type">uint</span>           <span class="comment">// 容量</span></span><br><span class="line">buf      unsafe.Pointer <span class="comment">// 存放元素的环形缓冲区</span></span><br><span class="line">elemsize <span class="type">uint16</span><span class="comment">// 元素类型的大小</span></span><br><span class="line">closed   <span class="type">uint32</span><span class="comment">// channel是否关闭</span></span><br><span class="line">elemtype *_type <span class="comment">// 元素类型</span></span><br><span class="line">sendx    <span class="type">uint</span>   <span class="comment">// channel发送操作处理的位置</span></span><br><span class="line">recvx    <span class="type">uint</span>   <span class="comment">// channel接收操作处理的位置</span></span><br><span class="line">recvq    waitq  <span class="comment">// 因接收而陷入阻塞的协程队列，即（ &lt;-ch ）</span></span><br><span class="line">sendq    waitq  <span class="comment">// 因发送而陷入阻塞的协程队列，即（ ch&lt;- ）</span></span><br><span class="line"></span><br><span class="line">lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-waitq"><a href="#1-2-waitq" class="headerlink" title="1.2 waitq"></a>1.2 waitq</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻塞的协程队列，是一个双向链表</span></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">first *sudog<span class="comment">// 表头</span></span><br><span class="line">last  *sudog<span class="comment">// 表尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-sudog"><a href="#1-3-sudog" class="headerlink" title="1.3 sudog"></a>1.3 sudog</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">g *g</span><br><span class="line">next *sudog</span><br><span class="line">prev *sudog</span><br><span class="line">elem unsafe.Pointer <span class="comment">// 指向数据元素 (可能指向栈)</span></span><br><span class="line">acquiretime <span class="type">int64</span></span><br><span class="line">releasetime <span class="type">int64</span></span><br><span class="line">ticket      <span class="type">uint32</span></span><br><span class="line">isSelect <span class="type">bool</span></span><br><span class="line">success  <span class="type">bool</span></span><br><span class="line">parent   *sudog <span class="comment">// semaRoot 二叉树</span></span><br><span class="line">waitlink *sudog <span class="comment">// g.waiting list or semaRoot</span></span><br><span class="line">waittail *sudog <span class="comment">// semaRoot</span></span><br><span class="line">c        *hchan <span class="comment">// channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>sudog：对<code>goroutine</code>的封装，表示一个在等待队列中的<code>g</code></p></li><li><p>g：协程</p></li><li><p>next：链表的下一个节点</p></li><li><p>prev：链表的前一个节点</p></li><li><p>elem：指向数据</p></li><li><p>isSelect：表示<code>g</code>是否被选择</p></li><li><p>success：表示<code>channel</code>c上的通信是否成功</p></li></ul><p>直接看数据结构的定义，可能会有点不理解，下面通过图来辅助理解</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230825143137015.png" alt="image-20230825143137015"></p><blockquote><p>图片来源:<a href="https://halfrost.com/go_channel/#toc-6">https://halfrost.com/go_channel/#toc-6</a></p></blockquote><p>其中<code>sendx</code>可能指向的是<code>5</code>边上那块还没有数据的区域，即如果执行ch &lt;- data$，那么<code>data</code>将被存储到这块区域。</p><p>同理<code>recvx</code>指向的是<code>0</code>，如果执行<code>&lt;-ch</code>首先会得到0，然后<code>recvx</code>会指向下一个</p><p>如果<code>buf</code>中存放的元素已经达到容量，此时还有<code>g</code>在执行发送操作给<code>ch</code>的话，即<code>ch&lt;-data</code>则会被添加到<code>sendq</code>队列中去，直到通道中的元素不再是满的。</p><p>同理<code>buf</code>是空的， 此时还有<code>g</code>在执行接收操作的话，即<code>&lt;-ch</code>则会被添加到<code>recvq</code>队列中去，直到通道中有元素。</p><h3 id="2-创建channel"><a href="#2-创建channel" class="headerlink" title="2 创建channel"></a>2 创建channel</h3><p>创建<code>channel</code>的函数有两个，原型如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan64</span><span class="params">(t *chantype, size <span class="type">int64</span>)</span></span> *hchan</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan</span><br></pre></td></tr></table></figure><p><code>makechan64</code>方法只是判断一下传入的<code>size</code>是否在<code>int32</code>范围内</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan64</span><span class="params">(t *chantype, size <span class="type">int64</span>)</span></span> *hchan &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="type">int64</span>(<span class="type">int</span>(size)) != size &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> makechan(t, <span class="type">int</span>(size))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的实现还是在<code>makechan</code>中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;</span><br><span class="line">elem := t.Elem</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器检查单个元素的大小不能超过64KB</span></span><br><span class="line"><span class="keyword">if</span> elem.Size_ &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;makechan: invalid channel element type&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 检查是否对齐</span></span><br><span class="line"><span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.Align_ &gt; maxAlign &#123;</span><br><span class="line">throw(<span class="string">&quot;makechan: bad alignment&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 缓冲区大小检查，判断是否溢出</span></span><br><span class="line">mem, overflow := math.MulUintptr(elem.Size_, <span class="type">uintptr</span>(size))</span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c *hchan</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> mem == <span class="number">0</span>:</span><br><span class="line"><span class="comment">// 队列或者元素大小为0时</span></span><br><span class="line">c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line"><span class="comment">// Rac 竞争检查使用这个地址进行同步操作</span></span><br><span class="line">c.buf = c.raceaddr()</span><br><span class="line"><span class="keyword">case</span> elem.PtrBytes == <span class="number">0</span>:</span><br><span class="line"><span class="comment">// 元素不包含指针时，一次性分配hchan和buf的内存</span></span><br><span class="line">c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// 元素包含指针时,则分别申请hchan和buf的空间，两者无需连续</span></span><br><span class="line">c = <span class="built_in">new</span>(hchan)</span><br><span class="line">c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将其余字段赋初始值</span></span><br><span class="line">c.elemsize = <span class="type">uint16</span>(elem.Size_)</span><br><span class="line">c.elemtype = elem</span><br><span class="line">c.dataqsiz = <span class="type">uint</span>(size)</span><br><span class="line">lockInit(&amp;c.lock, lockRankHchan)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debugChan &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;makechan: chan=&quot;</span>, c, <span class="string">&quot;; elemsize=&quot;</span>, elem.Size_, <span class="string">&quot;; dataqsiz=&quot;</span>, size, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-发送数据"><a href="#3-发送数据" class="headerlink" title="3 发送数据"></a>3 发送数据</h3><p>发送数据的操作有两个函数<code>chansend1()</code>和<code>chansend()</code>，不过实现逻辑都在后者，所以直接看它怎么实现的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="comment">// 判断 channel 是否为nil</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceBlockForever, <span class="number">2</span>)</span><br><span class="line">throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">  lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先对<code>channel</code>进行检查，如果已经被<code>GC</code>回收，往一个<code>nil</code>的通道发送数据会发送阻塞。<code>gopark</code>会引发以waitReasonChanSendNilChan为原因的休眠，并抛出一个<code>unreachable</code>的错误。</li><li>其次向已经关闭的<code>channel</code>发送数据时会报”send on closed channel”的错误</li></ul><p>下面将发送过程分为三种情况</p><h4 id="3-1-写时存在阻塞的读协程——直接发送"><a href="#3-1-写时存在阻塞的读协程——直接发送" class="headerlink" title="3.1 写时存在阻塞的读协程——直接发送"></a>3.1 写时存在阻塞的读协程——直接发送</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果存在阻塞的读协程时，会直接从<code>recvq</code>中取出最先陷入等待（遵循FIFO原则）的<code>Goroutine</code>并直接向它发送数据，绕过缓冲区</p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230825220928571.png" alt="image-20230825220928571" style="zoom:33%;" /><p>发送时的具体的执行逻辑由<code>send()</code>函数来完成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">sendDirect(c.elemtype, sg, ep)</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">unlockf()</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>send()</code>函数主要完成了2件事情：</p><ol><li>调用<code>sendDirect()</code>函数将发送的数据直接拷贝到<code>x = &lt;-ch</code>表达式中变量<code>x</code>所在的内存地址上，使用的是<code>memmove()</code>函数。</li><li>调用<code>goready()</code>将等待接收的<code>g</code>的状态从<code>Gwaiting</code>或者<code>Gscanwaiting</code>变成<code>Grunnable</code>，并把该<code>g</code>放到<code>runnext</code>中，处理器在下一次调度时会立即运行它，具体逻辑可以看<code>runqput()</code>函数的代码。需要注意是，<strong>发送数据的过程并没有立即执行接收发的<code>g</code>，只是将<code>g</code>放到<code>runnext</code>中，下一次调度的时候再执行。</strong></li></ol><h4 id="3-2-channel带有缓冲区，空间还未满并且不存在阻塞的读协程"><a href="#3-2-channel带有缓冲区，空间还未满并且不存在阻塞的读协程" class="headerlink" title="3.2 channel带有缓冲区，空间还未满并且不存在阻塞的读协程"></a>3.2 channel带有缓冲区，空间还未满并且不存在阻塞的读协程</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">qp := chanbuf(c, c.sendx)</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racenotify(c, c.sendx, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">c.sendx++</span><br><span class="line"><span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">c.sendx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">c.qcount++</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>qcount</code>还没有满，则调用<code> chanbuf()</code> 获取 <code>sendx</code> 索引的元素指针值。调用 <code>typedmemmove()</code> 方法将发送的值拷贝到缓冲区 <code>buf</code> 中。拷贝完成，需要维护 <code>sendx </code>索引下标值和<code> qcount</code> 个数。这里将 <code>buf</code> 缓冲区设计成环形的，索引值如果到了队尾，下一个位置重新回到队头。</p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230826133707785.png" alt="image-20230826133707785" style="zoom:50%;" /><blockquote><p>图片来源：<a href="https://halfrost.com/go_channel/#toc-10">https://halfrost.com/go_channel/#toc-10</a></p></blockquote><h4 id="3-3-channel带有缓冲区，空间已满并且不存在阻塞的读协程"><a href="#3-3-channel带有缓冲区，空间已满并且不存在阻塞的读协程" class="headerlink" title="3.3 channel带有缓冲区，空间已满并且不存在阻塞的读协程"></a>3.3 channel带有缓冲区，空间已满并且不存在阻塞的读协程</h4><p>这时向<code>channel</code>发送数据会进入阻塞状态</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">gp := getg()</span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.waiting = mysg</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">c.sendq.enqueue(mysg)</span><br><span class="line">gp.parkingOnChan.Store(<span class="literal">true</span>)</span><br><span class="line">gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceBlockChanSend, <span class="number">2</span>)</span><br><span class="line">KeepAlive(ep)</span><br></pre></td></tr></table></figure><ul><li><p>调用<code>getg()</code>方法获取当前<code>g</code>的指针，绑定到一个<code>sudog</code>上</p></li><li><p>调用<code>acquireSudog()</code>方法获取一个<code>sudog</code></p></li><li><p>调用<code>c.sendq.enqueue()</code>方法将配置好的<code>sudog</code>加入队列</p></li><li><p>调用<code>gopark()</code>挂起当前<code>g</code>，状态为<code>waitReasonChanSend</code>，阻塞等待<code>channel</code>发送</p></li><li><p>调用<code>KeepAlive()</code>保持活动状态，等待其它协程取走元素</p></li></ul><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230826135153228.png" alt="image-20230826135153228" style="zoom:50%;" /><blockquote><p>图片来源：<a href="https://halfrost.com/go_channel/#toc-10">https://halfrost.com/go_channel/#toc-10</a></p></blockquote><h3 id="4-接收数据"><a href="#4-接收数据" class="headerlink" title="4 接收数据"></a>4 接收数据</h3><p>接收数据的实现是在<code>chanrecv()</code>函数下实现的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从一个为nil的通道中接收数据会发生异常</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceBlockForever, <span class="number">2</span>)</span><br><span class="line">throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通道已经关闭且不存在缓存数据也会异常</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> c.qcount == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquire(c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, ep)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-读时存在阻塞的写协程"><a href="#4-1-读时存在阻塞的写协程" class="headerlink" title="4.1 读时存在阻塞的写协程"></a>4.1 读时存在阻塞的写协程</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从阻塞的<code>sendq</code>中获取头部的<code>g</code></li><li>如果缓冲区大小为0，则直接读取写协程元素，并唤醒它，这种情况只会发生一次<code>copy</code>操作即将阻塞的<code>g</code>所保存的元素复制到<code>read</code></li></ul><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230826151104338.png" alt="image-20230826151104338" style="zoom:50%;" /><ul><li>如果有缓冲区，则读取头部元素，并将处于等待发送的<code>g</code>的元素写入缓冲区的尾部（即刚刚读取的位置，因为是环形的），这种情况会发送两次<code>copy</code>操作，先将缓冲区<code>recvx</code>处的元素拷贝到<code>read</code>，然后将阻塞的<code>g</code>的元素拷贝到<code>sendx</code>所处的地址。</li></ul><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230826150504865.png" alt="image-20230826150504865" style="zoom:40%;" /><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230826151355877.png" alt="image-20230826151355877" style="zoom:40%;" /><blockquote><p>图片来源：<a href="https://halfrost.com/go_channel/#toc-16">https://halfrost.com/go_channel/#toc-16</a></p></blockquote><h4 id="4-2-读取时无阻塞的写协程且缓冲区有元素"><a href="#4-2-读取时无阻塞的写协程且缓冲区有元素" class="headerlink" title="4.2 读取时无阻塞的写协程且缓冲区有元素"></a>4.2 读取时无阻塞的写协程且缓冲区有元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">qp := chanbuf(c, c.recvx)</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racenotify(c, c.recvx, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">&#125;</span><br><span class="line">typedmemclr(c.elemtype, qp)</span><br><span class="line">c.recvx++</span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">c.recvx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">c.qcount--</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接将<code>recvx</code>处的元素拷贝给<code>read</code>，然后将对应的属性操作，<code>qcount</code>减1，<code>recvx</code>++，如果等于容量，则归0，可以理解为取模操作<code>(recvx++)%qcount</code></p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230826151746532.png" alt="image-20230826151746532" style="zoom:40%;" /><h4 id="4-3-读时没有阻塞的写协程且缓冲区无元素"><a href="#4-3-读时没有阻塞的写协程且缓冲区无元素" class="headerlink" title="4.3 读时没有阻塞的写协程且缓冲区无元素"></a>4.3 读时没有阻塞的写协程且缓冲区无元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">gp := getg()</span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">gp.waiting = mysg</span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">c.recvq.enqueue(mysg)</span><br><span class="line">gp.parkingOnChan.Store(<span class="literal">true</span>)</span><br><span class="line">gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanReceive, traceBlockChanRecv, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><ul><li><p>调用<code>getg()</code>方法获取当前<code>g</code>的指针，绑定到一个<code>sudog</code>上</p></li><li><p>调用<code>acquireSudog()</code>方法获取一个<code>sudog</code></p></li><li><p>调用<code>c.recvq.enqueue()</code>方法将配置好的<code>sudog</code>加入队列</p></li><li><p>调用<code>gopark()</code>挂起当前<code>g</code>，状态为<code>waitReasonChanReceive</code>，阻塞等待<code>channel</code>接收</p></li></ul><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230826152412808.png" alt="image-20230826152412808" style="zoom:50%;" /><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230826152442123.png" alt="image-20230826152442123" style="zoom:40%;" /><blockquote><p>图片来源<a href="https://halfrost.com/go_channel/#toc-16">https://halfrost.com/go_channel/#toc-16</a></p></blockquote><h3 id="5-关闭Channel"><a href="#5-关闭Channel" class="headerlink" title="5 关闭Channel"></a>5 关闭Channel</h3><p>关闭通道的实现在<code>closechan()</code>函数中:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;close of nil channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;close of closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">callerpc := getcallerpc()</span><br><span class="line">racewritepc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(closechan))</span><br><span class="line">racerelease(c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.closed = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>当关闭<code>channel</code>是<code>nil</code>或者是一个已经关闭的<code>channel</code>时，会直接<code>panic</code>，当不存在这两种情况的时候，标记<code>channel</code>状态为<code>close</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> glist gList</span><br><span class="line"><span class="comment">// release all readers</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sg := c.recvq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>recvq</code>队列中的<code>sudog</code>加入到待清除的队列<code>glist</code>中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// release all writers (they will panic)</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sg := c.sendq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;c.lock)</span><br></pre></td></tr></table></figure><p>将<code>sendq</code>队列中的<code>sudog</code>加入到待清除的队列<code>glist</code>中，这里可能会产生<code>panic</code></p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230826153540944.png" alt="image-20230826153540944"></p><blockquote><p>图片来源：<a href="https://halfrost.com/go_channel/#toc-16">https://halfrost.com/go_channel/#toc-16</a></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">gp := glist.pop()</span><br><span class="line">gp.schedlink = <span class="number">0</span></span><br><span class="line">goready(gp, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后会为所有被阻塞的 <code>g</code> 调用<code> goready</code> 触发调度。将所有<code>glist</code>中的<code> g</code> 状态从<code>_Gwaiting</code>设置为 <code>_Grunnable </code>状态，等待调度器的调度。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://speakerdeck.com/kavya719/understanding-channels?slide=32">kavya’s Understanding Channels</a></li><li><a href="https://halfrost.com/go_channel/#toc-0">https://halfrost.com/go_channel/#toc-0</a></li><li><a href="https://mp.weixin.qq.com/s/QgNndPgN1kqxWh-ijSofkw">https://mp.weixin.qq.com/s/QgNndPgN1kqxWh-ijSofkw</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码解读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Context源码解读</title>
      <link href="/2023/08/23/Context%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
      <url>/2023/08/23/Context%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>特别提醒，本文所涉及的源码是<code>go1.21.0 darwin/amd64</code></p></blockquote><h3 id="1-什么是Context"><a href="#1-什么是Context" class="headerlink" title="1. 什么是Context"></a>1. 什么是Context</h3><p>在多个goroutine之间传递上下文的对象，传递的信息包括取消信号、截止时间以及其他一些跨api边界的值</p><h3 id="2-核心数据结构"><a href="#2-核心数据结构" class="headerlink" title="2. 核心数据结构"></a>2. 核心数据结构</h3><h4 id="2-1-Context"><a href="#2-1-Context" class="headerlink" title="2.1 Context"></a>2.1 Context</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">  Err() <span class="type">error</span></span><br><span class="line">Value(key any) any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Context</code>定义为<code>Interface</code>，定义了4个核心函数：</p><ul><li>Dealine：返回<code>context</code>的过期时间和一个<code>bool</code>值判断是否设置了deadline</li><li>Done：返回<code>context</code>中的<code>channel</code>，该<code>channel</code>会在当前工作完成或者上下文被取消后关闭，多次调用返回的是同一个<code>channel</code>，如果该<code>context</code>是不能被取消的，则会返回<code>nil</code></li><li>Err：返回<code>context</code>结束的原因</li><li>Value：返回<code>contxet</code>中存储的key对应的值</li></ul><h4 id="2-2-error"><a href="#2-2-error" class="headerlink" title="2.2 error"></a>2.2 error</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Canceled = errors.New(<span class="string">&quot;context canceled&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DeadlineExceeded <span class="type">error</span> = deadlineExceededError&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> deadlineExceededError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Error() <span class="type">string</span>   &#123; <span class="keyword">return</span> <span class="string">&quot;context deadline exceeded&quot;</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Timeout() <span class="type">bool</span>   &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Temporary() <span class="type">bool</span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><ul><li>Canceled：<code>context</code>被cancel时会返回该类错误</li><li>DeadlineExceeded：<code>context</code>超时时会返回该类错误</li></ul><h3 id="3-具体实现"><a href="#3-具体实现" class="headerlink" title="3 具体实现"></a>3 具体实现</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230823100804205.png" alt="image-20230823100804205" style="zoom: 33%;" /></h3><h4 id="3-1-emptyCtx"><a href="#3-1-emptyCtx" class="headerlink" title="3.1 emptyCtx"></a>3.1 emptyCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(emptyCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(emptyCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(emptyCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(emptyCtx)</span></span> Value(key any) any &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>emptyCtx</code>是一个空的<code>context</code>，之前的一些版本中是直接将它定义为一个<code>int</code>类型</p><h4 id="3-2-backgroundCtx"><a href="#3-2-backgroundCtx" class="headerlink" title="3.2 backgroundCtx"></a>3.2 backgroundCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> backgroundCtx <span class="keyword">struct</span>&#123; emptyCtx &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(backgroundCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;context.Background&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span></span> Context &#123;</span><br><span class="line"><span class="keyword">return</span> backgroundCtx&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Background()</code>返回一个非nil但是为空的<code>context</code>。它不能被取消，没有任何值，也没有截止时间。通常被主函数、初始化、测试以及作为传入请求的顶层<code>context</code>使用。</p><h4 id="3-3-todoCtx"><a href="#3-3-todoCtx" class="headerlink" title="3.3 todoCtx"></a>3.3 todoCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> todoCtx <span class="keyword">struct</span>&#123; emptyCtx &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(todoCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;context.TODO&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span></span> Context &#123;</span><br><span class="line"><span class="keyword">return</span> todoCtx&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TODO()</code>同样返回一个非nil但是为空的<code>context</code>。在代码不清楚应该使用哪个上下文或者上下文尚不可用时，应该使用<code>context.TODO</code></p><h4 id="3-4-cancelCtx"><a href="#3-4-cancelCtx" class="headerlink" title="3.4 cancelCtx"></a>3.4 cancelCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">Context</span><br><span class="line"></span><br><span class="line">mu       sync.Mutex            <span class="comment">// protects following fields</span></span><br><span class="line">done     atomic.Value          <span class="comment">// of chan struct&#123;&#125;, created lazily, closed by first cancel call</span></span><br><span class="line">children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">err      <span class="type">error</span>                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">cause    <span class="type">error</span>                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cancelCtx</code>是取消机制的关键</p><ul><li><p>其结构体嵌入了一个&#96;Context，作为其父类</p></li><li><p>mu：内置一把锁，用于多goroutine并发场景下的资源获取</p></li><li><p>done：原子类型的值，实际类型为<code>chan struct&#123;&#125;</code>，用来反应<code>cancelCtx</code>的生命周期</p></li><li><p>children：一个集合，保存了所有该<code>cancelCtx</code>的子<code>context</code></p></li><li><p>err：记录<code>cancelCtx</code>发生的错误</p></li><li><p>cause：记录<code>calcelCtx</code>被取消的原因</p></li></ul><h5 id="3-4-1-Value方法"><a href="#3-4-1-Value方法" class="headerlink" title="3.4.1 Value方法"></a>3.4.1 Value方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &amp;cancelCtxKey is the key that a cancelCtx returns itself for.</span></span><br><span class="line"><span class="keyword">var</span> cancelCtxKey <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Value(key any) any &#123;</span><br><span class="line"><span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> value(c.Context, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>key</code>的值为<code>&amp;cancelCtxKey</code>，则返回<code>cancelCtx</code>本身的指针，否则返回对应<code>key</code>存储的<code>value</code>值</p><h5 id="3-4-2-Done方法"><a href="#3-4-2-Done方法" class="headerlink" title="3.4.2 Done方法"></a>3.4.2 Done方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">d := c.done.Load()</span><br><span class="line"><span class="keyword">if</span> d != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> d.(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">d = c.done.Load()</span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">d = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">c.done.Store(d)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d.(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>前面提到<code>done</code>属性是一个原子类型的值,因此通过<code>atomic</code>包中的<code>Load()</code>函数获取它的值,如果它已经存在则直接返回</li><li>如果不存在则先加锁，然后创建一个新的<code>chan struct&#123;&#125;</code>，然后通过<code>Store()</code>赋值给<code>done</code>，可以看到这是一个懒加载机制，在第一次调用<code>c.Done()</code>的时候，该属性才被创建，返回值，然后解锁</li></ul><h5 id="3-4-3-Err方法"><a href="#3-4-3-Err方法" class="headerlink" title="3.4.3 Err方法"></a>3.4.3 Err方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line">err := c.err</span><br><span class="line">c.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加锁、读取值、解锁、返回结果</p><h5 id="3-4-4-propagateCancel方法"><a href="#3-4-4-propagateCancel方法" class="headerlink" title="3.4.4 propagateCancel方法"></a>3.4.4 propagateCancel方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> propagateCancel(parent Context, child canceler) &#123;</span><br><span class="line">c.Context = parent</span><br><span class="line"></span><br><span class="line">done := parent.Done()</span><br><span class="line"><span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="comment">// parent is already canceled</span></span><br><span class="line">child.cancel(<span class="literal">false</span>, parent.Err(), Cause(parent))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line"><span class="comment">// parent is a *cancelCtx, or derives from one.</span></span><br><span class="line">p.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// parent has already been canceled</span></span><br><span class="line">child.cancel(<span class="literal">false</span>, p.err, p.cause)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">p.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a, ok := parent.(afterFuncer); ok &#123;</span><br><span class="line"><span class="comment">// parent implements an AfterFunc method.</span></span><br><span class="line">c.mu.Lock()</span><br><span class="line">stop := a.AfterFunc(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">child.cancel(<span class="literal">false</span>, parent.Err(), Cause(parent))</span><br><span class="line">&#125;)</span><br><span class="line">c.Context = stopCtx&#123;</span><br><span class="line">Context: parent,</span><br><span class="line">stop:    stop,</span><br><span class="line">&#125;</span><br><span class="line">c.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goroutines.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">child.cancel(<span class="literal">false</span>, parent.Err(), Cause(parent))</span><br><span class="line"><span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法比较关键，会构建父子上下文之间的关联，当父上下文被取消时，子上下文也会被取消，不会出现状态不一致的情况</p><ul><li>首先将<code>parent</code>赋值给<code>Context</code>属性</li><li>如果父上下文不会取消，则直接返回</li><li>如果父上下文已经取消，则直接终止子上下文</li><li>如果父上下文是可以取消的上下文类型，即<code>cancelCtx</code>，则先加锁、然后将其加入到父上下文的<code>children</code>中，最后解锁</li><li>如果父上下文实现了<code>AfterFunc</code>方法，则在上下文被取消后，将子上下文也取消，通过调用一个<code>stop()</code>函数来实现的</li><li>如果都没满足前面的条件，则启动一个协程监控parent状态，倘若父上下文终止，则终止子上下文</li></ul><blockquote><p>进一步观察<code>parentCancelCtx</code>是如何校验<code>parent</code>是否为<code>cancelCtx</code>类型的</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> closedchan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">close</span>(closedchan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span></span> (*cancelCtx, <span class="type">bool</span>) &#123;</span><br><span class="line">done := parent.Done()</span><br><span class="line"><span class="keyword">if</span> done == closedchan || done == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">p, ok := parent.Value(&amp;cancelCtxKey).(*cancelCtx)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">pdone, _ := p.done.Load().(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> pdone != done &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>closedchan</code>表示一个已经关闭的通道</li><li>倘若<code>parent</code>的<code>channel</code>已经被关闭或者是不会被<code>cancel</code>的类型，则直接返回<code>false</code></li><li>倘若用<code>&amp;cancelCtxKey</code>能取到值并且得到的值是<code>parent</code>本身,返回<code>true</code>（<code>cancelCtx</code>的约定，<code>key</code>为<code>&amp;cancelCtxKey</code>的时候，返回的是<code>cancelCtx</code>本身的指针）</li></ul><h5 id="3-4-5-String方法"><a href="#3-4-5-String方法" class="headerlink" title="3.4.5 String方法"></a>3.4.5 String方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> contextName(c.Context) + <span class="string">&quot;.WithCancel&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回<code>cancelCtx</code>的名字</p><h5 id="3-4-6-cancel方法"><a href="#3-4-6-cancel方法" class="headerlink" title="3.4.6 cancel方法"></a>3.4.6 cancel方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err, cause <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;context: internal error: missing cancel error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> cause == <span class="literal">nil</span> &#123;</span><br><span class="line">cause = err</span><br><span class="line">&#125;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// already canceled</span></span><br><span class="line">&#125;</span><br><span class="line">c.err = err</span><br><span class="line">c.cause = cause</span><br><span class="line">d, _ := c.done.Load().(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">c.done.Store(closedchan)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">close</span>(d)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> acquiring the child&#x27;s lock while holding parent&#x27;s lock.</span></span><br><span class="line">child.cancel(<span class="literal">false</span>, err, cause)</span><br><span class="line">&#125;</span><br><span class="line">c.children = <span class="literal">nil</span></span><br><span class="line">c.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">removeChild(c.Context, c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>该方法接收三个参数，<code>removeFromParent</code>是一个<code>bool</code>值，表示需要从当前<code>context</code>的父<code>context</code>的<code>children</code>中删除</li><li>加锁，判断自己的<code>err</code>是否为空，如果不为空，说明已经被<code>cancel</code>，直接返回</li><li>处理 <code>cancelCtx</code> 的 <code>channel</code>，若<code> channel</code> 此前未初始化，则直接注入一个 <code>closedChan</code>，否则关闭该 <code>channel</code></li><li>遍历该<code>cancelCtx</code>的子<code>context</code>，依次将其<code>cancel</code></li><li>解锁，最后根据传入的参数<code>removeFromParent</code>，判断是否需要手动把 <code>cancelCtx</code> 从 <code>parent</code> 的<code> children</code> 集合中移除</li></ul><blockquote><p>走进 <code>removeChild</code> 方法中，观察如何将 <code>cancelCtx</code> 从<code> parent</code> 的<code> children</code> 集合 中移除：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeChild</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> s, ok := parent.(stopCtx); ok &#123;</span><br><span class="line">s.stop()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">p, ok := parentCancelCtx(parent)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">p.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> p.children != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(p.children, child)</span><br><span class="line">&#125;</span><br><span class="line">p.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果<code>parent</code>不是<code>cancelCtx</code>类型的，则直接返回（因为只有 <code>cancelCtx</code> 才有 <code>children</code>集合）</li><li>加锁，将集合中<code>key</code>为<code>child</code>的删除，解锁</li></ul><h4 id="3-5-timerCtx"><a href="#3-5-timerCtx" class="headerlink" title="3.5 timerCtx"></a>3.5 timerCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">cancelCtx</span><br><span class="line">timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line"></span><br><span class="line">deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>timerCtx</code>在<code>cancelCtx</code>的基础上，又做了一层封装，新增了一个<code>time.Timer</code>用于定时终止<code>context</code>，另外新增一个<code>deadline</code>用于记录过期时间</p><h5 id="3-5-1-Deadline方法"><a href="#3-5-1-Deadline方法" class="headerlink" title="3.5.1 Deadline方法"></a>3.5.1 Deadline方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> c.deadline, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回过期时间</p><h5 id="3-5-2-String方法"><a href="#3-5-2-String方法" class="headerlink" title="3.5.2 String方法"></a>3.5.2 String方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> contextName(c.cancelCtx.Context) + <span class="string">&quot;.WithDeadline(&quot;</span> +</span><br><span class="line">c.deadline.String() + <span class="string">&quot; [&quot;</span> +</span><br><span class="line">time.Until(c.deadline).String() + <span class="string">&quot;])&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回<code>context</code>的名字加上过期时间</p><h5 id="3-5-3-cancel方法"><a href="#3-5-3-cancel方法" class="headerlink" title="3.5.3 cancel方法"></a>3.5.3 cancel方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err, cause <span class="type">error</span>) &#123;</span><br><span class="line">c.cancelCtx.cancel(<span class="literal">false</span>, err, cause)</span><br><span class="line"><span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line"><span class="comment">// Remove this timerCtx from its parent cancelCtx&#x27;s children.</span></span><br><span class="line">removeChild(c.cancelCtx.Context, c)</span><br><span class="line">&#125;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">c.timer.Stop()</span><br><span class="line">c.timer = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>继承<code>cancelCtx</code>的<code>cancel</code>方法，进行处理</li><li>判断是否需要从 <code>parent</code> 的 <code>children</code> 集合 中移除，若是则进行处理</li><li>加锁、停止<code>time.Timer</code>、解锁返回</li></ul><h4 id="3-6-valueCtx"><a href="#3-6-valueCtx" class="headerlink" title="3.6 valueCtx"></a>3.6 valueCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">Context</span><br><span class="line">key, val any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>valueCtx</code>同样继承了<code>Context</code>，同时一个<code>valueCtx</code>只能存储一对<code>kv</code></p><h5 id="3-6-1-String方法"><a href="#3-6-1-String方法" class="headerlink" title="3.6.1 String方法"></a>3.6.1 String方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> contextName(c.Context) + <span class="string">&quot;.WithValue(type &quot;</span> +</span><br><span class="line">reflectlite.TypeOf(c.key).String() +</span><br><span class="line"><span class="string">&quot;, val &quot;</span> + stringify(c.val) + <span class="string">&quot;)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回<code>valueCtx</code>的名字以及存储的<code>kv</code>值</p><h5 id="3-6-2-Value方法"><a href="#3-6-2-Value方法" class="headerlink" title="3.6.2 Value方法"></a>3.6.2 Value方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> Value(key any) any &#123;</span><br><span class="line"><span class="keyword">if</span> c.key == key &#123;</span><br><span class="line"><span class="keyword">return</span> c.val</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> value(c.Context, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果参数的<code>key</code>等于他所保存的<code>key</code>则返回所保存的<code>value</code></li><li>否则去<code>parent</code>的<code>Context</code>去找</li></ul><p>进一步观察是如何在<code>parent</code>中寻找的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">value</span><span class="params">(c Context, key any)</span></span> any &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> ctx := c.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *valueCtx:</span><br><span class="line"><span class="keyword">if</span> key == ctx.key &#123;</span><br><span class="line"><span class="keyword">return</span> ctx.val</span><br><span class="line">&#125;</span><br><span class="line">c = ctx.Context</span><br><span class="line"><span class="keyword">case</span> *cancelCtx:</span><br><span class="line"><span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line">c = ctx.Context</span><br><span class="line"><span class="keyword">case</span> withoutCancelCtx:</span><br><span class="line"><span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line"><span class="comment">// This implements Cause(ctx) == nil</span></span><br><span class="line"><span class="comment">// when ctx is created using WithoutCancel.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">c = ctx.c</span><br><span class="line"><span class="keyword">case</span> *timerCtx:</span><br><span class="line"><span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;ctx.cancelCtx</span><br><span class="line">&#125;</span><br><span class="line">c = ctx.Context</span><br><span class="line"><span class="keyword">case</span> backgroundCtx, todoCtx:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> c.Value(key)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动一个 for 循环，一直往上去父上下文中寻找</li><li>其中不同的上下文类型会有不同的处理方式；</li><li>找到匹配的 key，则将该value 进行返回.</li></ul>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码解读 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
