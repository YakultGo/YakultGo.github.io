<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>x/sync拓展库</title>
      <link href="/2024/04/18/x-sync%E6%8B%93%E5%B1%95%E5%BA%93/"/>
      <url>/2024/04/18/x-sync%E6%8B%93%E5%B1%95%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>特别提醒，本文所涉及的源码是<code>go1.22.2 darwin/amd64</code><br>x/sync包的版本是<code>v0.7.0</code></p></blockquote><p><code>x</code>目录下的包一般认为是<code>go</code>的官方拓展库</p><h3 id="singleflight"><a href="#singleflight" class="headerlink" title="singleflight"></a>singleflight</h3><p>定义：<code>Package singleflight provides a duplicate function call suppression mechanism</code></p><p>意思就是<strong>提供了一个重复的函数调用抑制机制</strong></p><p>一般有如下两种应用场景，能减少缓存击穿的风险。</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20240418173405122.png" alt="image-20240418173405122"></p><p>现在来看看具体的源码</p><h4 id="3个结构体"><a href="#3个结构体" class="headerlink" title="3个结构体"></a>3个结构体</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> call <span class="keyword">struct</span> &#123;</span><br><span class="line">wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存放fn函数调用的返回值</span></span><br><span class="line">val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">err <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并的请求数</span></span><br><span class="line">dups  <span class="type">int</span></span><br><span class="line">    <span class="comment">// 调用DoChan的返回结果</span></span><br><span class="line">chans []<span class="keyword">chan</span>&lt;- Result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">mu sync.Mutex       <span class="comment">// 互斥访问m</span></span><br><span class="line">m  <span class="keyword">map</span>[<span class="type">string</span>]*call <span class="comment">// 懒加载</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于DoChan调用</span></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">Val    <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">Err    <span class="type">error</span></span><br><span class="line">Shared <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于同样的key只会执行一次fn函数调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> Do(key <span class="type">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)) (v <span class="keyword">interface</span>&#123;&#125;, err <span class="type">error</span>, shared <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">    g.mu.Lock()</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">if</span> g.m == <span class="literal">nil</span> &#123;</span><br><span class="line">g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*call)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 发现已经被调用</span></span><br><span class="line"><span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">        <span class="comment">// 参数更新，等待</span></span><br><span class="line">c.dups++</span><br><span class="line">g.mu.Unlock()</span><br><span class="line">c.wg.Wait()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> e, ok := c.err.(*panicError); ok &#123;</span><br><span class="line"><span class="built_in">panic</span>(e)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> c.err == errGoexit &#123;</span><br><span class="line">runtime.Goexit()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c.val, c.err, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 第一次调用，则新建，添加进map</span></span><br><span class="line">c := <span class="built_in">new</span>(call)</span><br><span class="line">c.wg.Add(<span class="number">1</span>)</span><br><span class="line">g.m[key] = c</span><br><span class="line">    <span class="comment">// 解释</span></span><br><span class="line">g.mu.Unlock()</span><br><span class="line"><span class="comment">// 执行fn的调用</span></span><br><span class="line">g.doCall(c, key, fn)</span><br><span class="line"><span class="keyword">return</span> c.val, c.err, c.dups &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> doCall(c *call, key <span class="type">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)) &#123;</span><br><span class="line">normalReturn := <span class="literal">false</span></span><br><span class="line">recovered := <span class="literal">false</span></span><br><span class="line"><span class="comment">// 使用双延迟机制来区分panic和runtime.Goexit</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !normalReturn &amp;&amp; !recovered &#123;</span><br><span class="line">c.err = errGoexit</span><br><span class="line">&#125;</span><br><span class="line">g.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> g.mu.Unlock()</span><br><span class="line">c.wg.Done()</span><br><span class="line">        <span class="comment">// 删除key</span></span><br><span class="line"><span class="keyword">if</span> g.m[key] == c &#123;</span><br><span class="line"><span class="built_in">delete</span>(g.m, key)</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 如果是panic，往外抛</span></span><br><span class="line"><span class="keyword">if</span> e, ok := c.err.(*panicError); ok &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(c.chans) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="built_in">panic</span>(e)</span><br><span class="line"><span class="keyword">select</span> &#123;&#125; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(e)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> c.err == errGoexit &#123;</span><br><span class="line"><span class="comment">// goexit则直接退出</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> c.chans &#123;</span><br><span class="line">ch &lt;- Result&#123;c.val, c.err, c.dups &gt; <span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !normalReturn &#123;</span><br><span class="line">c.err = newPanicError(r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// 调用fn函数</span></span><br><span class="line">c.val, c.err = fn()</span><br><span class="line">normalReturn = <span class="literal">true</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// 捕获错误</span></span><br><span class="line"><span class="keyword">if</span> !normalReturn &#123;</span><br><span class="line">recovered = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DoChan</code>相比于<code>Do</code>是它属于异步调用，返回一个<code>channel</code>，解决同步调用时的阻塞问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> DoChan(key <span class="type">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)) &lt;-<span class="keyword">chan</span> Result &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Result, <span class="number">1</span>)</span><br><span class="line">g.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> g.m == <span class="literal">nil</span> &#123;</span><br><span class="line">g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*call)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">c.dups++</span><br><span class="line">c.chans = <span class="built_in">append</span>(c.chans, ch)</span><br><span class="line">g.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line">c := &amp;call&#123;chans: []<span class="keyword">chan</span>&lt;- Result&#123;ch&#125;&#125;</span><br><span class="line">c.wg.Add(<span class="number">1</span>)</span><br><span class="line">g.m[key] = c</span><br><span class="line">g.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> g.doCall(c, key, fn)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="errorgroup"><a href="#errorgroup" class="headerlink" title="errorgroup"></a>errorgroup</h3><p>主要用于协调多个<code>goroutine</code>的并发执行，并且能够可以返回错误，这是<code>WaitGroup</code>所不能做到的事情</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// context的cancel方法</span></span><br><span class="line">cancel <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">error</span>)</span></span></span><br><span class="line">wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">sem <span class="keyword">chan</span> token</span><br><span class="line"><span class="comment">// 保证只处理一次错误</span></span><br><span class="line">errOnce sync.Once</span><br><span class="line">err     <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用这个并发执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> Go(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> g.sem != <span class="literal">nil</span> &#123;</span><br><span class="line">g.sem &lt;- token&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">g.wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> g.done()</span><br><span class="line">        <span class="comment">// 执行业务逻辑f()</span></span><br><span class="line"><span class="keyword">if</span> err := f(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 如果发生错误，则调用这个只执行一次</span></span><br><span class="line">g.errOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">g.err = err</span><br><span class="line">                <span class="comment">// 如果有cancel函数，则调用cancel</span></span><br><span class="line"><span class="keyword">if</span> g.cancel != <span class="literal">nil</span> &#123;</span><br><span class="line">g.cancel(g.err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待所有g完成</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> Wait() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 等待所有g完成</span></span><br><span class="line">g.wg.Wait()</span><br><span class="line"><span class="keyword">if</span> g.cancel != <span class="literal">nil</span> &#123;</span><br><span class="line">g.cancel(g.err)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 返回是否有错误</span></span><br><span class="line"><span class="keyword">return</span> g.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——树</title>
      <link href="/2024/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%91/"/>
      <url>/2024/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="1-树"><a href="#1-树" class="headerlink" title="1 树"></a>1 树</h3><p>树是由<code>n</code>个节点构成的有限集，其中当<code>n=0</code>时，称为空树。并且树恰好有<code>n-1</code>条边。</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20240417175415414.png" alt="image-20240417175415414" style="zoom:33%;" /></p><p>其中<code>A</code>是树的根</p><h3 id="2-二叉树"><a href="#2-二叉树" class="headerlink" title="2 二叉树"></a>2 二叉树</h3><p>顾名思义，二叉树就是一个节点只有两个子节点</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20240417175551894.png" alt="image-20240417175551894" style="zoom: 33%;" /></p><p>左边的子节点称为左孩子，右边的节点称为右孩子。二叉树就有比较多的性质了：</p><ol><li>节点数量为<code>n</code>，则边的数量为<code>n-1</code></li><li>度为2的节点个数等于叶子节点个数-1，即$n_2=n_0 -1$</li><li>第<code>k</code>层（k$\geq1$）有$2^k-1$个节点</li><li>节点<code>i</code>（i$\geq 1$）的左儿子编号为$2\times i$ ，由儿子编号为 $ 2\times i+1$</li></ol><p>有下面几种遍历顺序：</p><ol><li>先序遍历</li><li>中序遍历</li><li>后序遍历</li><li>层序遍历</li></ol><h3 id="3-二叉搜素树"><a href="#3-二叉搜素树" class="headerlink" title="3 二叉搜素树"></a>3 二叉搜素树</h3><p>二叉搜索树的左孩子节点的值小于父节点的值，右孩子节点的值大于父节点的值。</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20240417180753315.png" alt="image-20240417180753315" style="zoom:33%;" /></p><p>由于它具有这样的性质，因此查找一个在树上的值，可以使用到二分思想查找，时间复杂度为$O(log n)$，但是在极端情况下，即一条链的时候还是$O(n)$，因此有各种各样的平衡树来解决这个问题。</p><h3 id="4-AVL树"><a href="#4-AVL树" class="headerlink" title="4 AVL树"></a>4 AVL树</h3><p>AVL树是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20240417181206467.png" alt="image-20240417181206467" style="zoom:33%;" /></p><p>二叉树的平衡化有两大基础操作： 左旋和右旋。左旋，即是逆时针旋转；右旋，即是顺时针旋转。这种旋转在整个平衡化过程中可能进行一次或多次，这两种操作都是从失去平衡的最小子树根结点开始的(即离插入结点最近且平衡因子超过1的祖结点)。</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20240417181240554.png" alt="image-20240417181240554"></p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20240417181256401.png" alt="image-20240417181256401"></p><p>优点：适用于查询场景</p><p>缺点：容易频繁的调整，因此不适用于修改频繁的场景，这也是为什么红黑树用的多的原因。</p><h3 id="5-红黑树"><a href="#5-红黑树" class="headerlink" title="5 红黑树"></a>5 红黑树</h3><p>红黑树是一棵二叉搜索树，它在每个结点上增加了一个存储位来表示结点的颜色，可以是RED或BLACK。通过对任何一条从根到叶子的简单路径上各个结点的颜色进行约束，红黑树确 保没有一条路径会比其他路径长出 2 倍，因而是近似平衡的。</p><p>红黑树的原则有以下几点：</p><ul><li>特性1：节点非黑即红</li><li>特性2：根节点一定是黑色</li><li>特性3：叶子节点（NIL）一定是黑色</li><li>特性4：每个红色节点的两个子节点都为黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li><li>特性5：从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点。</li></ul><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20240417195426936.png" alt="image-20240417195426936" style="zoom:50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis字典源码学习</title>
      <link href="/2023/10/27/Redis%E5%AD%97%E5%85%B8%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/10/27/Redis%E5%AD%97%E5%85%B8%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>特别提醒，本文所涉及的代码是redis3.0，由《Redis设计与实现》作者所注释的版本：<a href="https://github.com/huangz1990/redis-3.0-annotated">地址</a></p><p>与字典相关的文件在<code>dict.h</code>和<code>dict.c</code>两个文件中</p></blockquote><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p><code>dictEntry</code>是字典中的单个节点，即一个<code>k-v</code>对，注意到这里的值是一个<code>union</code>联合体，键值对中的值可以是一个指向实际值的指针即<code>val</code>，或者是一个无符号的 64 位整数<code>u64</code>或有符号的 64 位整数<code>s64</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><p><code>dictht</code>是一个哈希表，其中存放了很多个链表节点，每个链表是一个<code>dictEntry</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="type">int</span> rehashidx; </span><br><span class="line">    <span class="comment">// 目前正在运行的安全迭代器的数量</span></span><br><span class="line">    <span class="type">int</span> iterators; </span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p><code>dict</code>是<code>redis</code>中真正提供给外面使用的字典，其中有多个字段，这里只关注核心的两个字段<code>dictht ht[2]</code>和<code>int rehashidx</code>。这里要创建两个哈希表是为了方便<code>rehash</code>，<code>rehashidx</code>主要用于渐进式哈希。</p><p>可能第一眼看上面有三个相关的数据结构，有点不太好理解，下面画一个图来描述三者的关系：</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20231027153704840.png" alt="image-20231027153704840"></p><p>下面介绍学习一下<code>dict</code>的一些增删改查的源码</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>在字典<code>dict</code>中查找<code>key</code>在哪个链表中，如果存在该<code>key</code>则返回<code>-1</code>，不存在则返回哈希值，即应该在哪个链表中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> _dictKeyIndex(dict *d, <span class="type">const</span> <span class="type">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> h, idx, table;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    <span class="keyword">if</span> (_dictExpandIfNeeded(d) == DICT_ERR)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 计算 key 的哈希值</span></span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        <span class="comment">// 计算索引值</span></span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        <span class="comment">// 查找 key 是否存在</span></span><br><span class="line">        <span class="comment">// T = O(1)</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dictCompareKeys(d, key, he-&gt;key))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果运行到这里时，说明 0 号哈希表中所有节点都不包含 key</span></span><br><span class="line">        <span class="comment">// 如果这时 rehahs 正在进行，那么继续对 1 号哈希表进行 rehash</span></span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回索引值</span></span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>首先调用函数<code>_dictExpandIfNeeded(d)</code>判断当前字典是否需要进行扩容</li><li>先遍历<code>ht[0]</code>中的链表，然后计算<code>key</code>的哈希值，如果该链表中查询到则直接返回</li><li>如果在<code>ht[0]</code>的链表中没找到，则要先判断该字典是否处在<code>rehash</code>中，如果不在，则直接返回前面计算到的<code>idx</code>，否则还要去<code>ht[1]</code>对应的链表中查找</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> _dictExpandIfNeeded(dict *d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 渐进式 rehash 已经在进行了，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    <span class="comment">// 如果字典（的 0 号哈希表）为空，那么创建并返回初始化大小的 0 号哈希表</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line">    <span class="comment">// 一下两个条件之一为真时，对字典进行扩展</span></span><br><span class="line">    <span class="comment">// 1）字典已使用节点数和字典大小之间的比率接近 1：1</span></span><br><span class="line">    <span class="comment">//    并且 dict_can_resize 为真</span></span><br><span class="line">    <span class="comment">// 2）已使用节点数和字典大小之间的比率超过 dict_force_resize_ratio</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp;</span><br><span class="line">        (dict_can_resize ||</span><br><span class="line">         d-&gt;ht[<span class="number">0</span>].used/d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 新哈希表的大小至少是目前已使用节点数的两倍</span></span><br><span class="line">        <span class="comment">// T = O(N)</span></span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果字典还未初始化，则进行初始化操作，初始化链表数组大小为4</li><li>满足两个条件之一，则需要进行扩容操作：字典已使用节点数和字典大小之间的比率接近 <code>1:1</code>并且 <code>dict_can_resize</code> 为真，或者已使用节点数和字典大小之间的比率超过 <code>dict_force_resize_ratio</code>，该值为5。</li><li>扩容时有个小细节，就是它调用<code>dictExpand(d, d-&gt;ht[0].used*2)</code>，传入的大小为已经存在的<code>k-v</code>对的两倍</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dictExpand</span><span class="params">(dict *d, <span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 新哈希表</span></span><br><span class="line">    dictht n;</span><br><span class="line">    <span class="comment">// 根据 size 参数，计算哈希表的大小</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> realsize = _dictNextPower(size);</span><br><span class="line">    <span class="comment">// 不能在字典正在 rehash 时进行</span></span><br><span class="line">    <span class="comment">// size 的值也不能小于 0 号哈希表的当前已使用节点</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="number">0</span>].used &gt; size)</span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    <span class="comment">// 为哈希表分配空间，并将所有指针指向 NULL</span></span><br><span class="line">    n.size = realsize;</span><br><span class="line">    n.sizemask = realsize<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    n.table = zcalloc(realsize*<span class="keyword">sizeof</span>(dictEntry*));</span><br><span class="line">    n.used = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果 0 号哈希表为空，那么这是一次初始化：</span></span><br><span class="line">    <span class="comment">// 程序将新哈希表赋给 0 号哈希表的指针，然后字典就可以开始处理键值对了。</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].table == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = n;</span><br><span class="line">        <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 0 号哈希表非空，那么这是一次 rehash ：</span></span><br><span class="line">    <span class="comment">// 程序将新哈希表设置为 1 号哈希表，</span></span><br><span class="line">    <span class="comment">// 并将字典的 rehash 标识打开，让程序可以开始对字典进行 rehash</span></span><br><span class="line">    d-&gt;ht[<span class="number">1</span>] = n;</span><br><span class="line">    d-&gt;rehashidx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先会根据传入的<code>size</code>大小，找到第一个大于等于<code>size</code>的<code>2</code>的幂次方</li><li>如果<code>ht[0]</code>为空，则说明这是一次初始化操作</li><li>如果非空，则说明这是一次<code>rehash</code>操作，需要打开<code>rehash</code>标识，让字典在进行增删改查的时候进行渐进式哈希。</li></ul><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p>往一个字典<code>dict</code>中添加一个<code>k-v</code>对，如果<code>key</code>已经存在字典当中，则添加失败，否则插入该<code>k-v</code>对</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dictAdd</span><span class="params">(dict *d, <span class="type">void</span> *key, <span class="type">void</span> *val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 尝试添加键到字典，并返回包含了这个键的新哈希节点</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    dictEntry *entry = dictAddRaw(d,key);</span><br><span class="line">    <span class="comment">// 键已存在，添加失败</span></span><br><span class="line">    <span class="keyword">if</span> (!entry) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    <span class="comment">// 键不存在，设置节点的值</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    dictSetVal(d, entry, val);</span><br><span class="line">    <span class="comment">// 添加成功</span></span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先调用<code>dictAddRaw</code>函数，判断字典<code>d</code>中是否存在<code>key</code></li><li>如果已经存在则直接返回错误</li><li>不存在，则插入，并且返回成功</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">dictEntry *<span class="title function_">dictAddRaw</span><span class="params">(dict *d, <span class="type">void</span> *key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line">    <span class="comment">// 如果条件允许的话，进行单步 rehash</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    <span class="comment">// 计算键在哈希表中的索引值</span></span><br><span class="line">    <span class="comment">// 如果值为 -1 ，那么表示键已经存在</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    <span class="comment">// 如果字典正在 rehash ，那么将新键添加到 1 号哈希表</span></span><br><span class="line">    <span class="comment">// 否则，将新键添加到 0 号哈希表</span></span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 为新节点分配空间</span></span><br><span class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</span><br><span class="line">    <span class="comment">// 将新节点插入到链表表头</span></span><br><span class="line">    entry-&gt;next = ht-&gt;table[index];</span><br><span class="line">    ht-&gt;table[index] = entry;</span><br><span class="line">    <span class="comment">// 更新哈希表已使用节点数量</span></span><br><span class="line">    ht-&gt;used++;</span><br><span class="line">    <span class="comment">// 设置新节点的键</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    dictSetKey(d, entry, key);</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先判断字典是否处在<code>rehash</code>中，如果是，则顺带执行单步<code>rehash</code></li><li>首先使用<code>_dictKeyIndex(d, key)</code>获取到插入到哪个链表的索引</li><li>如果当前正在<code>rehash</code>则应该插入到<code>ht[1]</code>表中，否则是<code>ht[0]</code>表中</li><li>插入到链表的头部（时间复杂度是O(1)）</li></ul><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>如果键不存在，则将给定的键值对添加到字典中，如果键已经存在，那么删除旧有的键值对</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dictReplace</span><span class="params">(dict *d, <span class="type">void</span> *key, <span class="type">void</span> *val)</span></span><br><span class="line">&#123;</span><br><span class="line">    dictEntry *entry, auxentry;</span><br><span class="line">    <span class="comment">// 尝试直接将键值对添加到字典</span></span><br><span class="line">    <span class="comment">// 如果键 key 不存在的话，添加会成功</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">if</span> (dictAdd(d, key, val) == DICT_OK)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 运行到这里，说明键 key 已经存在，那么找出包含这个 key 的节点</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    entry = dictFind(d, key);</span><br><span class="line">    <span class="comment">// 先保存原有的值的指针</span></span><br><span class="line">    auxentry = *entry;</span><br><span class="line">    <span class="comment">// 然后设置新的值</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    dictSetVal(d, entry, val);</span><br><span class="line">    <span class="comment">// 然后释放旧值</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    dictFreeVal(d, &amp;auxentry);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先调用<code>dictAdd(d, key, val)</code>判断是否成功，如果成功说明是添加操作，否则要进行修改操作</li><li>调用<code>dictFind(d, key)</code>找到该<code>key</code>对应的节点，修改其中的值</li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>查找并删除包含给定键的节点，成功删除返回<code>DICT_OK</code>，没找到则返回<code>DICT_ERR</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dictGenericDelete</span><span class="params">(dict *d, <span class="type">const</span> <span class="type">void</span> *key, <span class="type">int</span> nofree)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> h, idx;</span><br><span class="line">    dictEntry *he, *prevHe;</span><br><span class="line">    <span class="type">int</span> table;</span><br><span class="line">    <span class="comment">// 字典（的哈希表）为空</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> DICT_ERR; <span class="comment">/* d-&gt;ht[0].table is NULL */</span></span><br><span class="line">    <span class="comment">// 进行单步 rehash ，T = O(1)</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    <span class="comment">// 计算哈希值</span></span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line">    <span class="comment">// 遍历哈希表</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        <span class="comment">// 计算索引值 </span></span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        <span class="comment">// 指向该索引上的链表</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        prevHe = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 遍历链表上的所有节点</span></span><br><span class="line">        <span class="comment">// T = O(1)</span></span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dictCompareKeys(d, key, he-&gt;key)) &#123;</span><br><span class="line">                <span class="comment">// 超找目标节点</span></span><br><span class="line">                <span class="comment">// 从链表中删除</span></span><br><span class="line">                <span class="keyword">if</span> (prevHe)</span><br><span class="line">                    prevHe-&gt;next = he-&gt;next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    d-&gt;ht[table].table[idx] = he-&gt;next;</span><br><span class="line">                <span class="comment">// 释放调用键和值的释放函数？</span></span><br><span class="line">                <span class="keyword">if</span> (!nofree) &#123;</span><br><span class="line">                    dictFreeKey(d, he);</span><br><span class="line">                    dictFreeVal(d, he);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 释放节点本身</span></span><br><span class="line">                zfree(he);</span><br><span class="line">                <span class="comment">// 更新已使用节点数量</span></span><br><span class="line">                d-&gt;ht[table].used--;</span><br><span class="line">                <span class="comment">// 返回已找到信号</span></span><br><span class="line">                <span class="keyword">return</span> DICT_OK;</span><br><span class="line">            &#125;</span><br><span class="line">            prevHe = he;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果执行到这里，说明在 0 号哈希表中找不到给定键</span></span><br><span class="line">        <span class="comment">// 那么根据字典是否正在进行 rehash ，决定要不要查找 1 号哈希表</span></span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没找到</span></span><br><span class="line">    <span class="keyword">return</span> DICT_ERR; <span class="comment">/* not found */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果当前正在<code>rehash</code>，则协同进行单步的<code>rehash</code>操作</li><li>首先遍历<code>ht[0]</code>，如果在该链表中没找到，则取遍历<code>ht[1]</code>找到则直接删除</li></ul>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.s081-lab-pgtbl</title>
      <link href="/2023/10/22/MIT6-s081-lab-pgtbl/"/>
      <url>/2023/10/22/MIT6-s081-lab-pgtbl/</url>
      
        <content type="html"><![CDATA[<h3 id="Speed-up-systems-calls"><a href="#Speed-up-systems-calls" class="headerlink" title="Speed up systems calls"></a>Speed up systems calls</h3><blockquote><p>题目要求：为了加速某些系统调用，可以让用户空间和内核空间共享一片只读的物理内存空间，并放在<code>TRAPFRAME</code>下面</p></blockquote><p>根据题目意思就是放在红框这里</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20231022211710321.png" alt="image-20231022211710321"></p><p>首先需要在<code>proc.h</code>文件中的<code>proc</code>结构体添加一个成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">proc</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">spinlock</span> lock;</span><br><span class="line">    <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">procstate</span> state;  <span class="comment">// Process state</span></span><br><span class="line">    <span class="type">void</span> *chan;            <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">    <span class="type">int</span> killed;            <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">    <span class="type">int</span> xstate;            <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">    <span class="type">int</span> pid;               <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait_lock must be held when using this:</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">proc</span> *parent;  <span class="comment">// Parent process</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">    uint64 kstack;                  <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">    uint64 sz;                      <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">    <span class="type">pagetable_t</span> pagetable;          <span class="comment">// User page table</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">trapframe</span> *trapframe;    <span class="comment">// data page for trampoline.S</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">context</span> context;         <span class="comment">// swtch() here to run process</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">file</span> *ofile[NOFILE];     <span class="comment">// Open files</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">inode</span> *cwd;              <span class="comment">// Current directory</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];                  <span class="comment">// Process name (debugging)</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">usyscall</span> *usyscallpage;  <span class="comment">// 共享内存页</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后在<code>proc.c</code>的函数<code>allocproc</code>多分配一个额外的物理页面，并且存放进程的<code>pid</code>，建议是放在<code>trapframe</code>代码的下面：</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20231022212202336.png" alt="image-20231022212202336"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一个user调用的页</span></span><br><span class="line"><span class="keyword">if</span> ((p-&gt;usyscallpage = (<span class="keyword">struct</span> usyscall *)<span class="built_in">kalloc</span>()) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">freeproc</span>(p);</span><br><span class="line">    <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;usyscallpage-&gt;pid = p-&gt;pid;</span><br></pre></td></tr></table></figure><p>并且需要在<code>proc_pagetable</code>函数中完成物理地址和虚拟地址的映射，也建议放在<code>trampoline</code>下面：</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20231022212425524.png" alt="image-20231022212425524"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">mappages</span>(pagetable, USYSCALL, PGSIZE, (uint64)(p-&gt;usyscallpage), PTE_R | PTE_U) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">uvmunmap</span>(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">uvmunmap</span>(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">uvmfree</span>(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就需要在进程释放函数<code>freeproc</code>中释放掉这个页面：</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20231022212535555.png" alt="image-20231022212535555"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p-&gt;usyscallpage)</span><br><span class="line">    <span class="built_in">kfree</span>((<span class="type">void</span> *)p-&gt;usyscallpage);</span><br><span class="line">p-&gt;usyscallpage = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>最最最后一步就是解除映射在<code>proc_freepagetable</code>函数中：</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20231022212735483.png" alt="image-20231022212735483"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uvmunmap</span>(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>至此第一个任务算是对大功告成了，其实我觉得这部分还挺麻烦的，而且还没怎么给提示，不知道为啥标记了个简单，我觉得第三个比这个容易写多了。。。</p><h3 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h3><blockquote><p>题目要求：设计一个函数打印页表</p></blockquote><p>这部分就毕竟简单了，一个<code>dfs</code>就搞定了。</p><p>根据题目要求完成<code>vm.c</code>文件中的<code>vmprint</code>函数，为了方便遍历，我还定义了一个<code>dfs</code>，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">        <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">        <span class="keyword">if</span> (pte &amp; PTE_V) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = level; j &lt;= <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; ..&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>, i, pte, <span class="built_in">PTE2PA</span>(pte));</span><br><span class="line">            <span class="keyword">if</span> (level != <span class="number">0</span>) &#123;</span><br><span class="line">                uint64 child = <span class="built_in">PTE2PA</span>(pte);</span><br><span class="line">                <span class="built_in">dfs</span>((<span class="type">pagetable_t</span>)child, level - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">    <span class="built_in">dfs</span>(pagetable, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后需要在<code>defs.h</code>中声明一个这个函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>    <span class="title">vmprint</span><span class="params">(<span class="type">pagetable_t</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>至此第二个任务也完成了</p><h3 id="Detecting-which-pages-have-been-accessed"><a href="#Detecting-which-pages-have-been-accessed" class="headerlink" title="Detecting which pages have been accessed"></a>Detecting which pages have been accessed</h3><blockquote><p>题目要求：给页表添加一位用于标记是否被访问，并实现<code>sys_pgaccess</code>系统调用</p></blockquote><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20231022213259048.png" alt="image-20231022213259048"></p><p>通过查阅上图发现，访问位是<code>6</code>，因此先在<code>riscv/h</code>文件中定义一个宏</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_A (1L &lt;&lt; 6)  <span class="comment">// access bit</span></span></span><br></pre></td></tr></table></figure><p>然后在<code>sysproc.c</code>文件中实现该系统调用，通过查看<code>pgaccess_test</code>函数发现，需要传入三个参数，首先调用<code>argaddr</code>和<code>argint</code>获取到系统调用的三个参数，然后调用<code>walk</code>函数得到每个需要确认的每个0级页表PTE，判断页面标志来确认是否被访问，最后不要忘记将页面的<code>PTE_A</code>标志清0：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// lab pgtbl: your code here.</span></span><br><span class="line">    uint64 addr, va;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    uint64 mask = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">argaddr</span>(<span class="number">0</span>, &amp;addr);</span><br><span class="line">    <span class="built_in">argint</span>(<span class="number">1</span>, &amp;len);</span><br><span class="line">    <span class="built_in">argaddr</span>(<span class="number">2</span>, &amp;va);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="type">pte_t</span> *pte = <span class="built_in">walk</span>(p-&gt;pagetable, addr + i * PGSIZE, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(*pte &amp; PTE_A) &#123;</span><br><span class="line">            mask |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            *pte &amp;= ~PTE_A; <span class="comment">// 将访问位清零</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">copyout</span>(p-&gt;pagetable, va, (<span class="type">char</span> *)&amp;mask, <span class="built_in">sizeof</span>(mask)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后第三个任务也大功告成</p><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20231022211453629.png" alt="image-20231022211453629" style="zoom:50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一致性哈希算法</title>
      <link href="/2023/10/16/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
      <url>/2023/10/16/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>一致性哈希的原理，可以直接看小林coding的<a href="https://www.xiaolincoding.com/os/8_network_system/hash.html#_9-4-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C">什么是一致性哈希</a></p><h3 id="Golang——groupcache"><a href="#Golang——groupcache" class="headerlink" title="Golang——groupcache"></a>Golang——groupcache</h3><p>在<code>golang</code>官方的仓库中有个名叫<code>groupcache</code>的仓库，里面提供了个简单的一致性哈希算法是<a href="https://github.com/golang/groupcache/blob/master/consistenthash/consistenthash.go">实现</a>，先简单分析一下这个的源码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> consistenthash</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;hash/crc32&quot;</span></span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Hash <span class="function"><span class="keyword">func</span><span class="params">(data []<span class="type">byte</span>)</span></span> <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">    hash     Hash<span class="comment">// 哈希函数</span></span><br><span class="line">    replicas <span class="type">int</span><span class="comment">// 每个节点对应的虚拟节点的数量</span></span><br><span class="line">    keys     []<span class="type">int</span> <span class="comment">// Sorted</span></span><br><span class="line">    hashMap  <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span><span class="comment">// 虚拟节点对应的实际节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(replicas <span class="type">int</span>, fn Hash)</span></span> *Map &#123;</span><br><span class="line">    m := &amp;Map&#123;</span><br><span class="line">        replicas: replicas,</span><br><span class="line">        hash:     fn,</span><br><span class="line">        hashMap:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> m.hash == <span class="literal">nil</span> &#123;</span><br><span class="line">        m.hash = crc32.ChecksumIEEE</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IsEmpty returns true if there are no items available.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> IsEmpty() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(m.keys) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add adds some keys to the hash.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Add(keys ...<span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m.replicas; i++ &#123;</span><br><span class="line">            hash := <span class="type">int</span>(m.hash([]<span class="type">byte</span>(strconv.Itoa(i) + key)))</span><br><span class="line">            m.keys = <span class="built_in">append</span>(m.keys, hash)</span><br><span class="line">            m.hashMap[hash] = key</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排序，方便二分查找，否则只能一个一个遍历</span></span><br><span class="line">    sort.Ints(m.keys)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get gets the closest item in the hash to the provided key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Get(key <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> m.IsEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hash := <span class="type">int</span>(m.hash([]<span class="type">byte</span>(key)))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到第一个虚拟节点</span></span><br><span class="line">    idx := sort.Search(<span class="built_in">len</span>(m.keys), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> m.keys[i] &gt;= hash &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没找到，则是第一个虚拟节点（环形）</span></span><br><span class="line">    <span class="keyword">if</span> idx == <span class="built_in">len</span>(m.keys) &#123;</span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m.hashMap[m.keys[idx]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>consistenthash</code>包对外提供了三个函数：</p><ol><li><code>New(replicas int, fn Hash)</code>：返回一个<code>Map</code>对象，这个<code>Map</code>对象是重新定义过的，其中<code>replicas</code>代表每个节点对应的虚拟节点的数量，<code>fn</code>代表哈希函数（<code>nil</code>的话会使用默认的哈希函数<code>crc32.ChecksumIEEE</code>），并且初始化一个<code>map</code>。</li><li><code>Add</code>：向哈希环上添加节点</li><li><code>Get</code>：传入一个<code>key</code>，获取其对应分配的实际节点</li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.s081-lab-syscall</title>
      <link href="/2023/10/15/MIT6-s081-lab-syscall/"/>
      <url>/2023/10/15/MIT6-s081-lab-syscall/</url>
      
        <content type="html"><![CDATA[<h3 id="Using-gdb"><a href="#Using-gdb" class="headerlink" title="Using gdb"></a>Using gdb</h3><blockquote><p>如果不知道怎么运行gdb的，要先看提供的<a href="https://pdos.csail.mit.edu/6.S081/2023/labs/gdb.html">文档</a></p></blockquote><p>1.首先在终端1中运行<code>make qemu-gdb</code>，结尾处会得到一个端口号，供终端2使用</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20231015163310695.png" alt="image-20231015163310695"></p><p>2.新起一个终端，运行<code>riscv64-unknown-elf-gdb</code>，会进入如下所示的界面</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20231015163444155.png" alt="image-20231015163444155" style="zoom:50%;" /></p><p>3.输入<code>target remote localhost: 25501</code>，然后再输入<code>file kernel/kernel</code>，就可以跟着指示往下做了</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20231015163657010.png" alt="image-20231015163657010" style="zoom:100%;" /></p><blockquote><p>问题1：Looking at the backtrace output, which function called <code>syscall</code>?</p><p>usertrap()</p></blockquote><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20231015163802691.png" alt="image-20231015163802691" style="zoom:100%;" /></p><blockquote><p>问题2：What is the value of <code>p-&gt;trapframe-&gt;a7</code> and what does that value represent? </p></blockquote><p>从<code>initcode.S</code>文件中看到<code>a7</code>保存的是要执行的系统调用号，从<code>syscall.h</code>中看到<code>7</code>是<code>SYS_exec</code></p><blockquote><p>7和exec的系统调用号</p></blockquote><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20231015164051477.png" alt=""></p><blockquote><p>问题3：What was the previous mode that the CPU was in?</p></blockquote><p>通过输入<code>p /x $sstatus</code>，得到<code>0x200000022</code>，通过查询相关文档得到之前的特权级别是<code>user mode</code>，其中的<code>8</code>这个位置<code>SPP</code>就表示源自什么模式（0表示用户模式）。</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20231015164751145.png" alt="image-20231015164751145"></p><blockquote><p>用户模式</p><p>问题4：Write down the assembly instruction the kernel is panicing at. Which register corresponds to the variable <code>num</code>?</p></blockquote><p>跟着作业的指示走，在<code>kernel.asm</code>文件中搜索地址可以看到：</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20231015200533042.png" alt="image-20231015200533042"></p><blockquote><p>在lw a3,0(zero)处panic，存在寄存器a3中</p><p>问题5：Why does the kernel crash? Hint: look at figure 3-3 in the text; is address 0 mapped in the kernel address space? Is that confirmed by the value in <code>scause</code> above?</p><p>内核因为加载了一个未使用的地址 0 处的内存数据而崩溃（Load page fault）。地址 0 并不映射到内核空间中（从 <code>0x80000000</code> 开始）。</p><p>问题6：What is the name of the binary that was running when the kernel paniced? What is its process id (<code>pid</code>)?</p><p>这个二进制的名字为 <code>initcode</code> ，其 process id 为 1.</p></blockquote><h3 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h3><blockquote><p>建议先读几遍作业文档，这两个作业需要实现的逻辑不难，但是这个流程稍微多了些</p></blockquote><ol><li>首先在<code>Makefile</code>中添加<code>$U/_trace\</code></li></ol><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20231016215601273.png" alt="image-20231016215601273" style="zoom:50%;" /></p><ol><li>然后在<code>user.h</code>文件中注册对应的函数</li></ol><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20231016215751599.png" style="zoom:50%;" /></p><ol><li>在<code>usys.pl</code>文件中也添加对应的入口</li></ol><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20231016215841421.png" alt="image-20231016215841421" style="zoom:50%;" /></p><ol><li>在<code>syscall.h</code>文件中添加对应的系统调用号</li></ol><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20231016220127159.png" alt="image-20231016220127159" style="zoom:50%;" /></p><ol><li>在<code>sysproc.c</code>文件中实现<code>sys_trace</code>函数，从用户态获取到用户输入的<code>mask</code>，然后赋值给进程的<code>syscall_trace</code>成员，该成员需要在<code>proc.h</code>文件中的<code>proc</code>结构体添加</li></ol><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20231016221346681.png" alt="image-20231016221346681" style="zoom:50%;" /></p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20231016220431358.png" alt="image-20231016220431358" style="zoom:50%;" /></p><ol><li>在<code>proc.c</code>文件中修改<code>fork</code>函数，在父进程创建子进程的时候将该值复制过去，如下</li></ol><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20231016220616830.png" alt="image-20231016220616830" style="zoom:50%;" /></p><ol><li>最后修改<code>syscall.c</code>文件中的<code>syscall</code>函数，在进行系统调用的时候根据<code>mask</code>打印相应的信息</li></ol><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20231016220722966.png" alt="image-20231016220722966" style="zoom:50%;" /></p><h3 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h3><p>该实验流程跟前面的差不多，这里主要描述一下<code>freemem</code>和<code>nproc</code>怎么计算得到的，根据课程的作业提示我们在<code>kalloc.c</code>文件中创建一个<code>count_freeMem</code>用来返回空闲的内存字节数，至于为什么是这么计算，因为可以看出来<code>xv6</code>系统使用的是空闲链表法来分配内存的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回空闲内存的字节数=空闲页数*每页字节数</span></span><br><span class="line">uint64 <span class="title function_">count_freeMem</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 先上锁</span></span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    uint64 bytes = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span> =</span> kmem.freelist;</span><br><span class="line">    <span class="keyword">while</span> (r) &#123;</span><br><span class="line">        bytes += PGSIZE;</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">    <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且在<code>proc.c</code>文件中创建一个<code>count_process</code>用来返回不是<code>UNUSED</code>状态的进程数量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回已经分配的进程数</span></span><br><span class="line">uint64 <span class="title function_">count_process</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    uint64 cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="comment">// 只有读请求，不需要上锁</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state != UNUSED)</span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个函数也都很直观，应该是没什么难度，最后跑一下<code>make grade</code>看看得分吧～</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20231016221308188.png" alt="image-20231016221308188" style="zoom:50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.s081-lab-util</title>
      <link href="/2023/10/14/MIT6-s081-lab-util/"/>
      <url>/2023/10/14/MIT6-s081-lab-util/</url>
      
        <content type="html"><![CDATA[<h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><blockquote><p>注意👇这三个头文件的顺序不能修改，如果IDE有自动排序include的功能要关闭，否则通过不了编译</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: need sleep seconds\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> time = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    sleep(time);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h3><blockquote><p>代码看起来比较多，其实核心比较少的，我加了很多close，这个文件里面可以不加，应该用不了几个文件描述符，但是下面那一题一定要加，否则过不了</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> p1[<span class="number">2</span>], p2[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="keyword">if</span> (pipe(p1) &lt; <span class="number">0</span> || pipe(p2) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;pipe failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        close(p1[<span class="number">1</span>]);</span><br><span class="line">        close(p2[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (read(p1[<span class="number">0</span>], buf, BUF_SIZE) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;read failed\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> pid = getpid();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (write(p2[<span class="number">1</span>], buf, BUF_SIZE) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;write failed\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(p1[<span class="number">0</span>]);</span><br><span class="line">        close(p2[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(p1[<span class="number">0</span>]);</span><br><span class="line">        close(p2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (write(p1[<span class="number">1</span>], buf, BUF_SIZE) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;write failed\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (read(p2[<span class="number">0</span>], buf, BUF_SIZE) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;read failed\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> pid = getpid();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, pid);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">        close(p1[<span class="number">1</span>]);</span><br><span class="line">        close(p2[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h3><blockquote><p>这题需要了解什么是质数筛，作业里面给出了个<a href="http://swtch.com/~rsc/thread/">链接</a>，解释了一下，这里我也简单画个图解释下该题的处理流程。</p></blockquote><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20231014112948202.png" alt="image-20231014112948202" style="zoom: 50%;" /></p><p>看懂了上面这个图，再看下面的代码就很清晰了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> left[<span class="number">2</span>])</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    read(left[<span class="number">0</span>], &amp;num, <span class="keyword">sizeof</span>(num));</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">-1</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, num);</span><br><span class="line">    <span class="type">int</span> right[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(right) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pipe failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 跟main函数做的一样</span></span><br><span class="line">        close(right[<span class="number">1</span>]);</span><br><span class="line">        close(left[<span class="number">0</span>]);</span><br><span class="line">        process(right);</span><br><span class="line">        close(right[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(right[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> buf;</span><br><span class="line">        <span class="keyword">while</span> (read(left[<span class="number">0</span>], &amp;buf, <span class="keyword">sizeof</span>(buf)) &amp;&amp; buf != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buf % num != <span class="number">0</span>)</span><br><span class="line">                write(right[<span class="number">1</span>], &amp;buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把-1传递给下一个进程</span></span><br><span class="line">        write(right[<span class="number">1</span>], &amp;buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        close(right[<span class="number">1</span>]);</span><br><span class="line">        close(left[<span class="number">0</span>]);</span><br><span class="line">        wait(<span class="number">0</span>);  <span class="comment">// 等待子进程处理完毕</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (pipe(p) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pipe failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程只读，因此关闭写</span></span><br><span class="line">        close(p[<span class="number">1</span>]);</span><br><span class="line">        process(p);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进场只写，关闭读</span></span><br><span class="line">        close(p[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= <span class="number">35</span>; i++) &#123;</span><br><span class="line">            write(p[<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        i = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 哨兵标识处理完毕</span></span><br><span class="line">        write(p[<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(i));</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);  <span class="comment">// 等待子进程处理完毕</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><blockquote><p>find主要注意不要处理”.”和”..”文件夹，否则会死循环下去，其他的就按照ls.c文件下面的写法</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fcntl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(path, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (st.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> T_DEVICE:</span><br><span class="line">    <span class="keyword">case</span> T_FILE:</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(path + <span class="built_in">strlen</span>(path) - <span class="built_in">strlen</span>(filename), filename) == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> T_DIR:</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span>(buf)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">        p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">        *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (de.inum == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            memmove(p, de.name, DIRSIZ);</span><br><span class="line">            p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (stat(buf, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            find(buf, filename);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;usage: find &lt;path&gt; &lt;filename&gt;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h3><blockquote><p>这部分可能不了解这个命令在linux有什么作用的人会不知所措，可以先去了解看看这个命令是干什么的，作业里面是比较简化的版本</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 512</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 检查命令行参数</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: xargs command\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将除第一个参数外的其他参数存储到一个数组中</span></span><br><span class="line">    <span class="type">char</span>* args[MAXARG + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">        args[index++] = argv[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从标准输入中读取一行行的文本</span></span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="type">char</span>* p = buf;</span><br><span class="line">    <span class="keyword">while</span> (read(<span class="number">0</span>, p, <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*p) == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 当读取到一行文本时，创建一个子进程</span></span><br><span class="line">            *p = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> pid;</span><br><span class="line">            <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 子进程</span></span><br><span class="line">                <span class="comment">// 将该行文本作为参数传递给指定的命令</span></span><br><span class="line">                args[index] = buf;</span><br><span class="line">                <span class="comment">// 执行指定的命令</span></span><br><span class="line">                exec(argv[<span class="number">1</span>], args);</span><br><span class="line">                <span class="comment">// 如果执行失败，则输出错误信息并退出子进程</span></span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;exec %s failed\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 父进程</span></span><br><span class="line">            <span class="comment">// 等待子进程执行完毕</span></span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 重置缓冲区指针，准备读取下一行文本</span></span><br><span class="line">            p = buf;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 继续读取下一个字符</span></span><br><span class="line">            ++p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 退出程序</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>最后要记住在主目录下面添加应该time.txt文件，然后写上一个整数，不然分数只有99</p></blockquote><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20231014113517139.png" alt="image-20231014113517139" style="zoom:50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双向链表list源码学习</title>
      <link href="/2023/09/25/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8list%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/09/25/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8list%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>特别提醒，本文所涉及的源码是<code>go1.21.0 darwin/amd64</code><br>文件位置：container/list/list.go</p></blockquote><h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1 数据结构"></a>1 数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Element <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 指向下一个节点和前一个节点</span></span><br><span class="line">    next, prev *Element</span><br><span class="line">    <span class="comment">// 标识当前element所属的List</span></span><br><span class="line">    list *List</span><br><span class="line">    <span class="comment">// 存储的当前节点值</span></span><br><span class="line">    Value any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">    root Element <span class="comment">// 哨兵节点</span></span><br><span class="line">    <span class="built_in">len</span>  <span class="type">int</span>     <span class="comment">// 链表长度（不算哨兵节点）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两者的关系如下图所示：</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230925202523466.png" alt="image-20230925202523466" style="zoom:50%;" /></p><h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2 初始化"></a>2 初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span></span> Init() *List &#123;</span><br><span class="line">    l.root.next = &amp;l.root</span><br><span class="line">    l.root.prev = &amp;l.root</span><br><span class="line">    l.<span class="built_in">len</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将哨兵节点的<code>next</code>和<code>prev</code>都指向自己，表示当前链表为空</li><li>长度<code>len</code>设置为0</li><li>返回一个<code>*List</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span> *List &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">new</span>(List).Init() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>外部通过调用<code>New()</code>创建一个双向链表</li></ul><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230925203236258.png" alt="image-20230925203236258" style="zoom:50%;" /></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span></span> lazyInit() &#123;</span><br><span class="line">    <span class="keyword">if</span> l.root.next == <span class="literal">nil</span> &#123;</span><br><span class="line">        l.Init()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>懒初始化：如果该链表还为初始化，则调用<code>Init()</code>函数来初始化</li></ul><h3 id="3-遍历"><a href="#3-遍历" class="headerlink" title="3 遍历"></a>3 遍历</h3><blockquote><p>返回当前节点的下一个节点</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Element)</span></span> Next() *Element &#123;</span><br><span class="line">    <span class="keyword">if</span> p := e.next; e.list != <span class="literal">nil</span> &amp;&amp; p != &amp;e.list.root &#123;</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果当前节点已经是最后一个节点，则返回<code>nil</code></li><li>返回当前节点的下一个节点</li></ul><blockquote><p>返回当前节点的前一个节点</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Element)</span></span> Prev() *Element &#123;</span><br><span class="line">    <span class="keyword">if</span> p := e.prev; e.list != <span class="literal">nil</span> &amp;&amp; p != &amp;e.list.root &#123;</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果当前节点已经是第一个节点，则返回<code>nil</code></li><li>返回当前节点的前一个节点</li></ul><blockquote><p>返回双向链表的第一个节点</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span></span> Front() *Element &#123;</span><br><span class="line">    <span class="keyword">if</span> l.<span class="built_in">len</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l.root.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>长度为0，则返回<code>nil</code></li></ul><blockquote><p>返回双向链表的最后一个节点</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span></span> Back() *Element &#123;</span><br><span class="line">    <span class="keyword">if</span> l.<span class="built_in">len</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l.root.prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>长度为0，则返回<code>nil</code></li></ul><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230925204108617.png" alt="image-20230925204108617" style="zoom:40%;" /></p><h3 id="4-插入"><a href="#4-插入" class="headerlink" title="4 插入"></a>4 插入</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在at元素后面插入e，并且返回e，并更新相应的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span></span> insert(e, at *Element) *Element &#123;</span><br><span class="line">    e.prev = at</span><br><span class="line">    e.next = at.next</span><br><span class="line">    e.prev.next = e</span><br><span class="line">    e.next.prev = e</span><br><span class="line">    e.list = l</span><br><span class="line">    l.<span class="built_in">len</span>++</span><br><span class="line">    <span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同样是插入一个元素在at后面，但是只提供一个value，需要帮他创建一个Element</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span></span> insertValue(v any, at *Element) *Element &#123;</span><br><span class="line">    <span class="keyword">return</span> l.insert(&amp;Element&#123;Value: v&#125;, at)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span></span> PushFront(v any) *Element &#123;</span><br><span class="line">    l.lazyInit()</span><br><span class="line">    <span class="keyword">return</span> l.insertValue(v, &amp;l.root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果链表<code>l</code>没有初始化，则先初始化</li><li>插入一个节点值为<code>v</code>的节点在链表<code>l</code>的头部</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span></span> PushBack(v any) *Element &#123;</span><br><span class="line">    l.lazyInit()</span><br><span class="line">    <span class="keyword">return</span> l.insertValue(v, l.root.prev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果链表<code>l</code>没有初始化，则先初始化</li><li>插入一个节点值为<code>v</code>的节点在链表<code>l</code>的尾部</li></ul><blockquote><p>插入一个节点值v在mark节点前面</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span></span> InsertBefore(v any, mark *Element) *Element &#123;</span><br><span class="line">    <span class="keyword">if</span> mark.list != l &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l.insertValue(v, mark.prev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>插入一个节点值v在mark节点后面      </p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span></span> InsertAfter(v any, mark *Element) *Element &#123;</span><br><span class="line">    <span class="keyword">if</span> mark.list != l &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l.insertValue(v, mark)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>将链表other中的节点依次插入到链表l的后面</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span></span> PushBackList(other *List) &#123;</span><br><span class="line">    l.lazyInit()</span><br><span class="line">    <span class="keyword">for</span> i, e := other.Len(), other.Front(); i &gt; <span class="number">0</span>; i, e = i<span class="number">-1</span>, e.Next() &#123;</span><br><span class="line">        l.insertValue(e.Value, l.root.prev)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>将链表other中d节点插入到链表l的前面</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span></span> PushFrontList(other *List) &#123;</span><br><span class="line">    l.lazyInit()</span><br><span class="line">    <span class="keyword">for</span> i, e := other.Len(), other.Back(); i &gt; <span class="number">0</span>; i, e = i<span class="number">-1</span>, e.Prev() &#123;</span><br><span class="line">        l.insertValue(e.Value, &amp;l.root)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-删除"><a href="#5-删除" class="headerlink" title="5 删除"></a>5 删除</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除节点e</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span></span> remove(e *Element) &#123;</span><br><span class="line">    e.prev.next = e.next</span><br><span class="line">    e.next.prev = e.prev</span><br><span class="line">    e.next = <span class="literal">nil</span> <span class="comment">// avoid memory leaks</span></span><br><span class="line">    e.prev = <span class="literal">nil</span> <span class="comment">// avoid memory leaks</span></span><br><span class="line">    e.list = <span class="literal">nil</span></span><br><span class="line">    l.<span class="built_in">len</span>--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span></span> Remove(e *Element) any &#123;</span><br><span class="line">    <span class="keyword">if</span> e.list == l &#123;</span><br><span class="line">        l.remove(e)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e.Value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果节点<code>e</code>在链表<code>l</code>中，则调用<code>remove()</code>函数移除该节点</li><li>返回节点<code>e</code>的值</li></ul><h3 id="6-移动"><a href="#6-移动" class="headerlink" title="6 移动"></a>6 移动</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将e移到at的后面</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span></span> move(e, at *Element) &#123;</span><br><span class="line">    <span class="keyword">if</span> e == at &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    e.prev.next = e.next</span><br><span class="line">    e.next.prev = e.prev</span><br><span class="line"></span><br><span class="line">    e.prev = at</span><br><span class="line">    e.next = at.next</span><br><span class="line">    e.prev.next = e</span><br><span class="line">    e.next.prev = e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>将节点e移到链表l前面</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span></span> MoveToFront(e *Element) &#123;</span><br><span class="line">    <span class="keyword">if</span> e.list != l || l.root.next == e &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    l.move(e, &amp;l.root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>将节点e移到链表l尾部</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span></span> MoveToBack(e *Element) &#123;</span><br><span class="line">    <span class="keyword">if</span> e.list != l || l.root.prev == e &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    l.move(e, l.root.prev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>将节点e移到节点mark的前面</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span></span> MoveBefore(e, mark *Element) &#123;</span><br><span class="line">    <span class="keyword">if</span> e.list != l || e == mark || mark.list != l &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    l.move(e, mark.prev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>将节点e移到节点mark的后面</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span></span> MoveAfter(e, mark *Element) &#123;</span><br><span class="line">    <span class="keyword">if</span> e.list != l || e == mark || mark.list != l &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    l.move(e, mark)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h3><p>从<code>list.go</code>源码中，看得出实现的还是很容易理解的，跟我们自己实现的双向链表几乎无差别，源码阅读起来应该也是毫无压力</p>]]></content>
      
      
      <categories>
          
          <category> 源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>trie前缀树</title>
      <link href="/2023/09/18/trie%E5%89%8D%E7%BC%80%E6%A0%91/"/>
      <url>/2023/09/18/trie%E5%89%8D%E7%BC%80%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h3><p><code>Trie</code>树，即字典树，又称前缀树，是一种树形结构，是一种哈希树的变种，像字典一样的树。</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230918162852921.png" alt="image-20230918162852921" style="zoom:40%;" /></p><p><code>Trie</code>的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的，使用<code>Trie</code>相比哈希查询的好处是，路由算法中需要模糊匹配，哈希是做不到的，它只能精确查找。</p><h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2 实现"></a>2 实现</h3><h4 id="2-1-字段"><a href="#2-1-字段" class="headerlink" title="2.1 字段"></a>2.1 字段</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> tag;</span><br><span class="line">    Trie *nxt[<span class="number">26</span>]&#123;&#125;;</span><br><span class="line">    <span class="built_in">Trie</span>(): <span class="built_in">tag</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先定义核心字段，<code>tag</code>用来表示当前节点是否是某个字符串的结尾，比如说如果在上面的树中，又来了一个<code>go</code>，那在第一个<code>o</code>中的<code>tag</code>应该标识为1</p><h4 id="2-2-插入"><a href="#2-2-插入" class="headerlink" title="2.2 插入"></a>2.2 插入</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> string &amp;s)</span> </span>&#123;</span><br><span class="line">    Trie *p = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> i : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;nxt[i - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p-&gt;nxt[i - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;nxt[i - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;tag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果子节点不存在，则新建一个子节点</p></li><li><p>移动p指针</p></li><li>将最后一个字符的<code>tag</code>置为1，标识一个字符串的末尾</li></ul><h4 id="2-3-查询"><a href="#2-3-查询" class="headerlink" title="2.3 查询"></a>2.3 查询</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">const</span> string &amp;s)</span> </span>&#123;</span><br><span class="line">    Trie *p = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> i : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;nxt[i - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;nxt[i - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;tag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果遍历到子节点为<code>nullptr</code>，则直接返回<code>false</code></li><li>移动<code>p</code>指针</li><li>判断最后一个<code>p-&gt;tag</code>是否为<code>1</code></li></ul><h4 id="2-4-前缀匹配"><a href="#2-4-前缀匹配" class="headerlink" title="2.4 前缀匹配"></a>2.4 前缀匹配</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(<span class="type">const</span> string &amp;prefix)</span> </span>&#123;</span><br><span class="line">    Trie *p = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> i : prefix) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;nxt[i-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        p = p-&gt;nxt[i-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>跟查询差不多</li></ul><p>整个类的完整实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> tag;</span><br><span class="line">    Trie *nxt[<span class="number">26</span>]&#123;&#125;;</span><br><span class="line">    <span class="built_in">Trie</span>(): <span class="built_in">tag</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> string &amp;s)</span> </span>&#123;</span><br><span class="line">        Trie *p = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> i : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;nxt[i - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                p-&gt;nxt[i - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;nxt[i - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;tag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">const</span> string &amp;s)</span> </span>&#123;</span><br><span class="line">        Trie *p = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> i : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;nxt[i - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;nxt[i - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;tag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(<span class="type">const</span> string &amp;prefix)</span> </span>&#123;</span><br><span class="line">        Trie *p = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> i : prefix) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;nxt[i-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p-&gt;nxt[i-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面提供一个<code>go</code>实现的版本</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;</span><br><span class="line">    nxt [<span class="number">26</span>]*Trie</span><br><span class="line">    tag <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span></span> Insert(word <span class="type">string</span>) &#123;</span><br><span class="line">    root := this</span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> word &#123;</span><br><span class="line">        <span class="keyword">if</span> root.nxt[c-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line">            root.nxt[c-<span class="string">&#x27;a&#x27;</span>] = &amp;Trie&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root = root.nxt[c-<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    root.tag = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span></span> Search(word <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    root := this</span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> word &#123;</span><br><span class="line">        <span class="keyword">if</span> root.nxt[c-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        root = root.nxt[c-<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root.tag == <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span></span> StartsWith(prefix <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    root := this</span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> prefix &#123;</span><br><span class="line">        <span class="keyword">if</span> root.nxt[c-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        root = root.nxt[c-<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要做题的话可以去试试这个 <a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">leetcode 208. 实现 Trie (前缀树)</a></p><h3 id="3-radix-tree"><a href="#3-radix-tree" class="headerlink" title="3 radix tree"></a>3 radix tree</h3><p><code>gin</code>框架并不是使用普通的<code>trie</code>树，而是一种经过压缩的<code>Radix Trie</code>又叫做基数树、基数特里树、压缩前缀树。</p><p><strong>当某个父节点仅有一个子节点，并且不存在字符串以该父节点为结尾的时候</strong>，会将父节点和子节点进行合并，则最前面的<code>trie</code>树就会变成下图：</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230918171430821.png" alt="image-20230918171430821" style="zoom:40%;" /></p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h3><p><a href="https://mp.weixin.qq.com/s/Ec2KyQ1ObyJuAOSvFa5xXg">HTTP Router 算法演进</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sync.map源码学习</title>
      <link href="/2023/09/12/sync-map%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/09/12/sync-map%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>特别提醒，本文所涉及的源码是<code>go1.21.0 darwin/amd64</code><br>文件位置：runtime/map.go</p></blockquote><p>普通的<code>map</code>并不是并发安全的一个数据结构，因此想要使用并发安全的<code>map</code>，<code>sync</code>包下提供了一个<code>sync.map</code>数据结构</p><h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1 数据结构"></a>1 数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 保护并发读写、写写</span></span><br><span class="line">    mu Mutex</span><br><span class="line">    read atomic.Pointer[readOnly]</span><br><span class="line">    dirty <span class="keyword">map</span>[any]*entry</span><br><span class="line">    misses <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>read：无锁化的<code>map</code>，实际类型为<code>atomic.Pointer</code></li><li>dirty：加锁的<code>map</code>，是一个普通的<code>map</code></li><li>misses：每次从<code>read</code>中读取失败，<code>misses</code>都会加1，达到一定阈值后，会将<code>dirty</code>提升为<code>read</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">    m       <span class="keyword">map</span>[any]*entry</span><br><span class="line">    amended <span class="type">bool</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>m：<code>read</code>中的<code>map</code>，存放<code>k-v</code>对</li><li>amended：标识<code>read</code>和<code>dirty</code>中的元素是否一致</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">    p atomic.Pointer[any]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>p：<code>k-v</code>对中的<code>value</code>，使用<code>atomic.Pointer</code>的形式，通过<code>entry.p</code>的指针来获取值</li></ul><h3 id="2-entry的几种状态"><a href="#2-entry的几种状态" class="headerlink" title="2 entry的几种状态"></a>2 entry的几种状态</h3><h4 id="2-1-p-nil（软删除）"><a href="#2-1-p-nil（软删除）" class="headerlink" title="2.1 p==nil（软删除）"></a>2.1 p==nil（软删除）</h4><p>此时<code>p</code>是<code>nil</code>，<code>m.dirty</code>等于<code>nil</code>或者<code>m.dirty[key]</code>指向该<code>entry</code></p><h4 id="2-2-p-expunged（硬删除）"><a href="#2-2-p-expunged（硬删除）" class="headerlink" title="2.2 p==expunged（硬删除）"></a>2.2 p==expunged（硬删除）</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 固定的全局变量，标识该entry已经从m.dirty中删除</span></span><br><span class="line"><span class="keyword">var</span> expunged = <span class="built_in">new</span>(any)</span><br></pre></td></tr></table></figure><h4 id="2-3-p指向正常值的地址"><a href="#2-3-p指向正常值的地址" class="headerlink" title="2.3 p指向正常值的地址"></a>2.3 p指向正常值的地址</h4><p>这种情况就是<code>k-v</code>对没删除的情况，可以通过<code>m.read.m[key]</code>找到，如果此时<code>dirty</code>也不为<code>nil</code>，同样也可以通过<code>m.dirty[key]</code>找到，两者实际指向的是同一个值。</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230913154004629.png" alt="image-20230913154004629" style="zoom:40%;" /></p><h3 id="3-Load"><a href="#3-Load" class="headerlink" title="3 Load"></a>3 Load</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Load(key any) (value any, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    <span class="comment">// read中没找到，则判断amended是否为true</span></span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        read = m.loadReadOnly()</span><br><span class="line">        <span class="comment">// double check，有可能在上锁的过程中，其中goroutine将dirty提升为read了</span></span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        <span class="comment">// 还是没有在read中找到对应key的value</span></span><br><span class="line">        <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">            e, ok = m.dirty[key]</span><br><span class="line">            <span class="comment">// misses++，如果超过阈值则将dirty提升为read</span></span><br><span class="line">            m.missLocked()</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e.load()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会调用<code>loadReadOnly</code>函数获取<code>read</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> loadReadOnly() readOnly &#123;</span><br><span class="line">    <span class="comment">// 因为read是atomic包下的类型，因此需要使用load函数获取</span></span><br><span class="line">    <span class="keyword">if</span> p := m.read.Load(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> readOnly&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果未初始化，则在该函数中初始化，否则直接返回<code>m.read</code></p><hr><p>通过<code>key</code>来读取<code>read.m</code>中的<code>value</code>，然后存在该元素则直接返回值就行，否则要上锁，再判断<code>m</code>中是否存在该<code>key</code>，如果还是不存在则去<code>dirty</code>中查找。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> missLocked() &#123;</span><br><span class="line">    m.misses++</span><br><span class="line">    <span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// misses超过dirty的长度，则将dirty提升为read，并将dirty置为nil</span></span><br><span class="line">    m.read.Store(&amp;readOnly&#123;m: m.dirty&#125;)</span><br><span class="line">    m.dirty = <span class="literal">nil</span></span><br><span class="line">    m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>如果在<code>read</code>和<code>dirty</code>都没找到，则返回<code>nil</code>，如果找到了则调用<code>load</code>返回对应的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> load() (value any, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    p := e.p.Load()</span><br><span class="line">    <span class="comment">// 然后p处于硬删除或者软删除状态，则返回nil</span></span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回地址p所指向的值</span></span><br><span class="line">    <span class="keyword">return</span> *p, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Store"><a href="#4-Store" class="headerlink" title="4 Store"></a>4 Store</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Store(key, value any) &#123;</span><br><span class="line">    _, _ = m.Swap(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Store</code>函数是通过调用<code>Swap</code>函数来实现逻辑功能的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Swap(key, value any) (previous any, loaded <span class="type">bool</span>) &#123;</span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    <span class="comment">// 如果read中存在该key，则尝试调用trySwap函数直接修改</span></span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">        <span class="comment">// 没被删除则直接更新,说明这次操作属于更新而非插入</span></span><br><span class="line">        <span class="keyword">if</span> v, ok := e.trySwap(&amp;value); ok &#123;</span><br><span class="line">            <span class="keyword">if</span> v == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *v, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    <span class="comment">// double check</span></span><br><span class="line">    read = m.loadReadOnly()</span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">        <span class="keyword">if</span> e.unexpungeLocked() &#123;</span><br><span class="line">            <span class="comment">// 如果p == expunged，则将read中p的状态更新为nil，然后在dirty插入该key</span></span><br><span class="line">            m.dirty[key] = e</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p不为nil的话，则直接更新</span></span><br><span class="line">        <span class="keyword">if</span> v := e.swapLocked(&amp;value); v != <span class="literal">nil</span> &#123;</span><br><span class="line">            loaded = <span class="literal">true</span></span><br><span class="line">            previous = *v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line">        <span class="comment">// read中不存在该key，但是dirty中存在，则也是直接更新</span></span><br><span class="line">        <span class="keyword">if</span> v := e.swapLocked(&amp;value); v != <span class="literal">nil</span> &#123;</span><br><span class="line">            loaded = <span class="literal">true</span></span><br><span class="line">            previous = *v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果都不存在该key</span></span><br><span class="line">        <span class="keyword">if</span> !read.amended &#123;</span><br><span class="line">            <span class="comment">// dirty为nil，则需要创建dirty，并从read中拷贝未删除的元素到dirty中</span></span><br><span class="line">            m.dirtyLocked()</span><br><span class="line">            <span class="comment">// 并且更新amended字段</span></span><br><span class="line">            m.read.Store(&amp;readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在dirty中写入新key</span></span><br><span class="line">        m.dirty[key] = newEntry(value)</span><br><span class="line">    &#125;</span><br><span class="line">    m.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> previous, loaded</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> trySwap(i *any) (*any, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        p := e.p.Load()</span><br><span class="line">        <span class="comment">// 如果p被硬删除了，则直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> p == expunged &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则将其存到entry中</span></span><br><span class="line">        <span class="keyword">if</span> e.p.CompareAndSwap(p, i) &#123;</span><br><span class="line">            <span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> dirtyLocked() &#123;</span><br><span class="line">    <span class="comment">// dirty 不为 nil则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[any]*entry, <span class="built_in">len</span>(read.m))</span><br><span class="line">    <span class="comment">// 遍历未被删除的key</span></span><br><span class="line">    <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">        <span class="keyword">if</span> !e.tryExpungeLocked() &#123;</span><br><span class="line">            m.dirty[k] = e</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-Delete"><a href="#5-Delete" class="headerlink" title="5 Delete"></a>5 Delete</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Delete(key any) &#123;</span><br><span class="line">    m.LoadAndDelete(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>map</code>的<code>Delete</code>操作都是调用<code>LoadAndDelete</code>来实现的，因此直接看它是怎么实现的即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> LoadAndDelete(key any) (value any, loaded <span class="type">bool</span>) &#123;</span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    <span class="comment">// read中不存在，并且dirty有read没有的key</span></span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">        <span class="comment">// 上锁</span></span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        read = m.loadReadOnly()</span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        <span class="comment">// double check</span></span><br><span class="line">        <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">            <span class="comment">// 在dirty中找到该key，则直接删除，并且调用missLocked</span></span><br><span class="line">            e, ok = m.dirty[key]</span><br><span class="line">            <span class="built_in">delete</span>(m.dirty, key)</span><br><span class="line">            m.missLocked()</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// read中存在，直接删除</span></span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        <span class="keyword">return</span> e.<span class="built_in">delete</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// read和dirty都不存在该key，返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> <span class="built_in">delete</span>() (value any, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        p := e.p.Load()</span><br><span class="line">        <span class="comment">// 如果p为nil和expunged则返回false</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否者将其p删除，置为nil</span></span><br><span class="line">        <span class="keyword">if</span> e.p.CompareAndSwap(p, <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> *p, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么这里删除<code>p</code>的时候不是直接将其置为<code>expunged</code>而是置为<code>nil</code>呢？</p><p>因为在<code>tryExpungeLocked</code>函数中，会将<code>nil</code>设置为<code>expunged</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> tryExpungeLocked() (isExpunged <span class="type">bool</span>) &#123;</span><br><span class="line">    p := e.p.Load()</span><br><span class="line">    <span class="keyword">for</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// p == nil，则将其置为expunged</span></span><br><span class="line">        <span class="keyword">if</span> e.p.CompareAndSwap(<span class="literal">nil</span>, expunged) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        p = e.p.Load()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p == expunged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到如果 key 同时存在于<code>read</code> 和 <code>dirty</code> 中时，删除只是做了一个标记，将<code>p</code> 置为 <code>nil</code>；而如果仅在 <code>dirty</code> 中含有这个 <code>key</code> 时，会直接删除这个<code>key</code>。原因在于，若两者都存在这个 <code>key</code>，仅做标记删除，可以在下次查找这个<code>key</code> 时，命中 <code>read</code>，提升效率。若只有在<code>dirty</code> 中存在时，<code>read</code> 起不到“缓存”的作用，直接删除。</p><h3 id="6-Range"><a href="#6-Range" class="headerlink" title="6 Range"></a>6 Range</h3><p>由用户实现，<code>Range</code>将遍历<code>map</code>中的所有<code>k-v</code>对，将他们传给<code>f</code>函数，如果<code>f</code>返回<code>false</code>则停止遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Range(f <span class="function"><span class="keyword">func</span><span class="params">(key, value any)</span></span> <span class="type">bool</span>) &#123;</span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    <span class="comment">// amended为true</span></span><br><span class="line">    <span class="keyword">if</span> read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        read = m.loadReadOnly()</span><br><span class="line">        <span class="comment">// double check</span></span><br><span class="line">        <span class="keyword">if</span> read.amended &#123;</span><br><span class="line">            <span class="comment">// 将dirty拷贝给read</span></span><br><span class="line">            read = readOnly&#123;m: m.dirty&#125;</span><br><span class="line">            m.read.Store(&amp;read)</span><br><span class="line">            m.dirty = <span class="literal">nil</span></span><br><span class="line">            m.misses = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历read</span></span><br><span class="line">    <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">        v, ok := e.load()</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !f(k, v) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h3><p>什么时候会出现<code>expunge</code>？</p><p>当<code>key</code>的值在 <code>read</code> 中为 <code>nil</code>，随后由其他操作触发<code>read</code> 向 <code>dirty</code> 复制，<code>nil</code> 被转变为<code>expunge</code>。此时 <code>dirty</code> 不为空，且<code>key</code> 在<code>dirty</code> 中不存在。</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230913193828380.png" alt="image-20230913193828380" style="zoom:50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sync.RWMutex源码学习</title>
      <link href="/2023/09/08/sync-RWMutex%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/09/08/sync-RWMutex%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>特别提醒，本文所涉及的源码是<code>go1.21.0 darwin/amd64</code><br>文件位置：runtime/slice.go</p></blockquote><h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1 数据结构"></a>1 数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    w           Mutex        <span class="comment">// 写锁</span></span><br><span class="line">    writerSem   <span class="type">uint32</span>       <span class="comment">// 写操作等待读操作完成</span></span><br><span class="line">    readerSem   <span class="type">uint32</span>       <span class="comment">// 读操作等待写操作完</span></span><br><span class="line">    readerCount atomic.Int32 </span><br><span class="line">    readerWait  atomic.Int32 </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> rwmutexMaxReaders = <span class="number">1</span> &lt;&lt; <span class="number">30</span></span><br></pre></td></tr></table></figure><ul><li>readerCount：在没有写锁介入的时候，表示的是当前正在读操作的数量。如果有写介入，则<code>readerCount</code>+<code>rwmutexMaxReaders</code>等于正在读操作的数量</li><li>readerWait：在能够获取写锁前，还需要等待多少个读协程释放读锁</li></ul><h3 id="2-写锁"><a href="#2-写锁" class="headerlink" title="2 写锁"></a>2 写锁</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock() &#123;</span><br><span class="line">    <span class="comment">// 首先与其他写锁操作争Mutex</span></span><br><span class="line">    rw.w.Lock()</span><br><span class="line">    <span class="comment">// 与其他写操作竞争成功</span></span><br><span class="line">    <span class="comment">// const rwmutexMaxReaders = 1 &lt;&lt; 30</span></span><br><span class="line">    <span class="comment">// readerCount减去rwmutexMaxReaders，阻塞后面的读操作，r表示当前正在进行读操作的数量</span></span><br><span class="line">    r := rw.readerCount.Add(-rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line">    <span class="comment">// 前面还有读操作，readerWait+=r，并阻塞挂起，等待唤醒</span></span><br><span class="line">    <span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; rw.readerWait.Add(r) != <span class="number">0</span> &#123;</span><br><span class="line">        runtime_SemacquireRWMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么获取写锁的时候要先减去rwmutexMaxReaders，阻塞后续的读操作呢？</p></blockquote><p>主要是防止后续不断的读操作导致写操作被「饿死」</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock() &#123;</span><br><span class="line">    <span class="comment">// 释放写锁</span></span><br><span class="line">    r := rw.readerCount.Add(rwmutexMaxReaders)</span><br><span class="line">    <span class="comment">// 如果之前就没加过写锁，直接报错</span></span><br><span class="line">    <span class="keyword">if</span> r &gt;= rwmutexMaxReaders &#123;</span><br><span class="line">        race.Enable()</span><br><span class="line">        fatal(<span class="string">&quot;sync: Unlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒readerCount个读操作</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(r); i++ &#123;</span><br><span class="line">        runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放写锁</span></span><br><span class="line">    rw.w.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-读锁"><a href="#3-读锁" class="headerlink" title="3 读锁"></a>3 读锁</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock() &#123;</span><br><span class="line">    <span class="comment">// readerCount+1，如果小于0，说明有写锁，因为写锁会减去rwmutexMaxReaders</span></span><br><span class="line">    <span class="keyword">if</span> rw.readerCount.Add(<span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 阻塞挂起，等待写锁的释放</span></span><br><span class="line">        runtime_SemacquireRWMutexR(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock() &#123;</span><br><span class="line">    <span class="comment">// readerCount-1，如果大于等于0直接释放成功</span></span><br><span class="line">    <span class="keyword">if</span> r := rw.readerCount.Add(<span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 如果小于0，说明前面有协程在等待获取写锁，则会进入rUnlockSlow方法中</span></span><br><span class="line">        rw.rUnlockSlow(r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> rUnlockSlow(r <span class="type">int32</span>) &#123;</span><br><span class="line">    <span class="comment">// 之前没有加过读锁，因此释放读锁会直接报错</span></span><br><span class="line">    <span class="keyword">if</span> r+<span class="number">1</span> == <span class="number">0</span> || r+<span class="number">1</span> == -rwmutexMaxReaders &#123;</span><br><span class="line">        race.Enable()</span><br><span class="line">        fatal(<span class="string">&quot;sync: RUnlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// readerWait-1等于0，说明该读操作是最后一个读操作，释放完它后，应该唤醒写操作</span></span><br><span class="line">    <span class="keyword">if</span> rw.readerWait.Add(<span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">        runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Try"><a href="#4-Try" class="headerlink" title="4 Try"></a>4 Try</h3><p><code>rwmutex.go</code>文件中除了上面提到的函数，还有两个<code>Try</code>函数，该函数只在特定场景下使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> TryRLock() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        c := rw.readerCount.Load()</span><br><span class="line">        <span class="comment">// 如果有写操作正在执行，则返回false</span></span><br><span class="line">        <span class="keyword">if</span> c &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 双重校验，再检查一下是否中间的过程中，有其他协程介入，没有则返回true</span></span><br><span class="line">        <span class="comment">// 否则继续循环</span></span><br><span class="line">        <span class="keyword">if</span> rw.readerCount.CompareAndSwap(c, c+<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> TryLock() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试获取写锁失败，则返回false</span></span><br><span class="line">    <span class="keyword">if</span> !rw.w.TryLock() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否有读操作在进行，有则返回false，并释放写锁</span></span><br><span class="line">    <span class="keyword">if</span> !rw.readerCount.CompareAndSwap(<span class="number">0</span>, -rwmutexMaxReaders) &#123;</span><br><span class="line">        <span class="comment">// 释放写锁</span></span><br><span class="line">        rw.w.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sync.Mutex源码学习</title>
      <link href="/2023/09/06/sync-Mutex%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/09/06/sync-Mutex%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>特别提醒，本文所涉及的源码是<code>go1.21.0 darwin/amd64</code></p><p>文件位置：sync/mutex.go</p><p>文章所涉及的go汇编代码都是以_amd64结尾的文件</p></blockquote><h3 id="1-前期知识"><a href="#1-前期知识" class="headerlink" title="1 前期知识"></a>1 前期知识</h3><h4 id="1-1-阻塞锁"><a href="#1-1-阻塞锁" class="headerlink" title="1.1 阻塞锁"></a>1.1 阻塞锁</h4><p>将当前协程阻塞挂起，直到锁被释放后，以回调的方式将阻塞协程重新唤醒，进行锁争夺</p><h4 id="1-2-自旋锁"><a href="#1-2-自旋锁" class="headerlink" title="1.2 自旋锁"></a>1.2 自旋锁</h4><p>结合<code>CAS</code>，重复校验锁的状态并尝试获取锁，始终占用<code>cpu</code></p><h4 id="1-3-对比"><a href="#1-3-对比" class="headerlink" title="1.3 对比"></a>1.3 对比</h4><div class="table-container"><table><thead><tr><th></th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>阻塞/唤醒</td><td>不占用cpu时间片</td><td>需要上下文切换</td></tr><tr><td>自旋</td><td>不会阻塞当前协程</td><td>占用cpu时间片</td></tr></tbody></table></div><h3 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2 数据结构"></a>2 数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    state <span class="type">int32</span></span><br><span class="line">    sema  <span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>state：状态表示，第1位表示是否上锁，第2位表示<code>mutex</code>是否被唤醒，第3位表示<code>mutex</code>是否处于饥饿模式</li><li>sema：控制锁状态的信号量</li></ul><h3 id="3-上锁"><a href="#3-上锁" class="headerlink" title="3 上锁"></a>3 上锁</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() &#123;</span><br><span class="line">    <span class="comment">// 初次尝试，state为0则直接抢锁成功</span></span><br><span class="line">    <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">        <span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">            race.Acquire(unsafe.Pointer(m))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 快速抢锁失败，则进入loclSlow慢速抢锁</span></span><br><span class="line">    m.lockSlow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要上锁逻辑还是在<code>lockSlow()</code>函数中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> lockSlow() &#123;</span><br><span class="line">    <span class="keyword">var</span> waitStartTime <span class="type">int64</span><span class="comment">// 抢锁所等待的时间</span></span><br><span class="line">    starving := <span class="literal">false</span><span class="comment">// 是否处于饥饿模式</span></span><br><span class="line">    awoke := <span class="literal">false</span><span class="comment">// 是否已有协程在等待锁</span></span><br><span class="line">    iter := <span class="number">0</span><span class="comment">// 自旋次数</span></span><br><span class="line">    old := m.state<span class="comment">// 锁的state</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 不处于饥饿模式，已经被上锁，并且满足自旋条件</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">            <span class="comment">// 将mutexWoken置为1，表明自己正在自旋，先不唤醒其他阻塞的协程（否则自旋无意义）</span></span><br><span class="line">            <span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">                awoke = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 自旋调用相关函数</span></span><br><span class="line">            runtime_doSpin()</span><br><span class="line">            <span class="comment">// 自旋次数+1</span></span><br><span class="line">            iter++</span><br><span class="line">            old = m.state</span><br><span class="line">            <span class="comment">// 继续自旋</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>其中的<code>CompareAndSwapInt32</code>是一种原子操作，汇编实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该文件在runtime/atomic_amd64.s</span></span><br><span class="line"><span class="comment">// bool Cas(int32 *val, int32 old, int32 new)</span></span><br><span class="line"><span class="comment">// Atomically:</span></span><br><span class="line"><span class="comment">//if(*val == old)&#123;</span></span><br><span class="line"><span class="comment">//*val = new;</span></span><br><span class="line"><span class="comment">//return 1;</span></span><br><span class="line"><span class="comment">//&#125; else</span></span><br><span class="line"><span class="comment">//return 0;</span></span><br><span class="line">TEXT ·Cas(SB),NOSPLIT,$<span class="number">0</span><span class="number">-17</span></span><br><span class="line">    MOVQptr+<span class="number">0</span>(FP), BX</span><br><span class="line">    MOVLold+<span class="number">8</span>(FP), AX</span><br><span class="line">    MOVL<span class="built_in">new</span>+<span class="number">12</span>(FP), CX</span><br><span class="line">    LOCK</span><br><span class="line">    CMPXCHGLCX, <span class="number">0</span>(BX)</span><br><span class="line">    SETEQret+<span class="number">16</span>(FP)</span><br><span class="line">    RET</span><br></pre></td></tr></table></figure><p>判断的逻辑很简单，就是<code>*val</code>跟<code>old</code>相等，则将<code>*val</code>更新为<code>new</code>并且返回<code>true</code>，否则返回<code>false</code></p><p>判断是否可以自旋的逻辑在<code>runtime/proc.go</code>文件中的<code>sync_runtime_canSpin</code>函数中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname sync_runtime_canSpin sync.runtime_canSpin</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_canSpin</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// active_spin=4 </span></span><br><span class="line">    <span class="keyword">if</span> i &gt;= active_spin || ncpu &lt;= <span class="number">1</span> || gomaxprocs &lt;= sched.npidle.Load()+sched.nmspinning.Load()+<span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> p := getg().m.p.ptr(); !runqempty(p) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自旋次数<code>iter</code>大于等于<code>4</code></li><li><p><code>cpu</code>核数小于等于1</p></li><li><p>当前<code>P</code>的执行队列中有等待执行的<code>g</code></p></li></ul><p>满足上述三种条件之一，则不满足自旋条件，不能进入自旋状态</p><p><code>runtime_doSpin</code>的相关实现也在<code>runtime/proc.go</code>下的<code>sync_runtime_doSpin</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname sync_runtime_doSpin sync.runtime_doSpin</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_doSpin</span><span class="params">()</span></span> &#123;</span><br><span class="line">    procyield(active_spin_cnt)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// procyield是用汇编实现的，文件在runtime/asm_amd64.s</span></span><br><span class="line"><span class="comment">// 其中AX的值是active_spin_cnt，并且active_spin_cnt=30</span></span><br><span class="line">TEXT runtime·procyield(SB),NOSPLIT,$<span class="number">0</span><span class="number">-0</span></span><br><span class="line">    MOVLcycles+<span class="number">0</span>(FP), AX</span><br><span class="line">again:</span><br><span class="line">    PAUSE</span><br><span class="line">    SUBL$<span class="number">1</span>, AX</span><br><span class="line">    JNZagain</span><br><span class="line">    RET</span><br></pre></td></tr></table></figure><p>通过汇编代码可以看出，<code>procyield</code>函数会执行30次的<code>PAUSE</code>指令，该指令会占用<code>CPU</code>并消耗<code>CPU</code>时间。</p><hr><p>现在回到<code>lockSlow</code>，继续看剩余的处理逻辑，此时不能再进行自旋操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复制当前的state状态，用来设置mutex的新状态</span></span><br><span class="line"><span class="built_in">new</span> := old</span><br><span class="line"><span class="comment">// old state非饥饿模式</span></span><br><span class="line"><span class="comment">// 如果当前协程抢锁成功或者已经是上锁状态的，new state都应该加锁</span></span><br><span class="line"><span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">new</span> |= mutexLocked</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// old state处于加锁状态或者饥饿状态，当前协程都会被阻塞，则等待数量+1</span></span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// old state已经上锁（表明当前协程在等待），并且处于饥饿状态，则将new state标记饥饿模式</span></span><br><span class="line"><span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">new</span> |= mutexStarving</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当前协程被唤醒，不管是拿到锁了，还是将要进入阻塞队列了，都应该取消mutexWoken标记</span></span><br><span class="line"><span class="keyword">if</span> awoke &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩余代码逻辑通过<code>CAS</code>来尝试设置锁的状态</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">    <span class="comment">// old state并没有上锁，也不是饥饿状态</span></span><br><span class="line">    <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 当前协程上锁成功</span></span><br><span class="line">        <span class="keyword">break</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果已经等待过了，说明是从阻塞队列被唤醒的协程，因为此次上锁失败，放回队列头部</span></span><br><span class="line">    queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line">    <span class="comment">// 如果是新来抢锁的，则初始化等待时间，并且放到队列尾部</span></span><br><span class="line">    <span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">        waitStartTime = runtime_nanotime()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过信号量来排队获取锁，通过sleep原语阻塞当前协程</span></span><br><span class="line">    runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// sleep结束，被唤醒</span></span><br><span class="line">    <span class="comment">// 如果当前协程等待时间超过1ms，则进入饥饿模式</span></span><br><span class="line">    starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">    <span class="comment">// 获取锁目前状态（可能被其他协程修改过）</span></span><br><span class="line">    old = m.state</span><br><span class="line">    <span class="comment">// 如果锁是饥饿模式，则锁应该是被释放的状态，当前协程是被信号量唤醒的，那么锁应该直接交给当前协程</span></span><br><span class="line">    <span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前锁是上锁的或者有协程在唤醒状态，或者阻塞队列为空，这与上面条件冲突，是非法状态</span></span><br><span class="line">        <span class="comment">// 因为饥饿模式下，锁应该是交给阻塞队列的头部的协程</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前协程获得锁，等待队列-1</span></span><br><span class="line">        delta := <span class="type">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">        <span class="comment">// 如果只剩一个等待者了，则退出饥饿模式</span></span><br><span class="line">        <span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">            delta -= mutexStarving</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新mutex状态，主要是减去等待者或者退出饥饿模式，并加上上锁状态</span></span><br><span class="line">        atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果锁不是饥饿模式，唤醒当前协程，重置自旋次数</span></span><br><span class="line">    awoke = <span class="literal">true</span></span><br><span class="line">    iter = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// CAS失败，重新尝试获取锁</span></span><br><span class="line">    old = m.state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来看看上面提到的<code>runtime_SemacquireMutex</code>函数，首先是调用<code>runtime/sema.go/poll_runtime_Semacquire</code>函数，接着它又调用<code>semacquire1</code>函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname poll_runtime_Semacquire internal/poll.runtime_Semacquire</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_Semacquire</span><span class="params">(addr *<span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">    semacquire1(addr, <span class="literal">false</span>, semaBlockProfile, <span class="number">0</span>, waitReasonSemacquire)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">semacquire1</span><span class="params">(addr *<span class="type">uint32</span>, lifo <span class="type">bool</span>, profile semaProfileFlags, skipframes <span class="type">int</span>, reason waitReason)</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="keyword">if</span> gp != gp.m.curg &#123;</span><br><span class="line">        throw(<span class="string">&quot;semacquire not on the G stack&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 抢占到信号量，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> cansemacquire(addr) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没抢到信号量:</span></span><br><span class="line">    <span class="comment">//等待者+1</span></span><br><span class="line">    <span class="comment">//继续尝试抢信号量，如果成功则返回</span></span><br><span class="line">    <span class="comment">//将自己入队</span></span><br><span class="line">    <span class="comment">//sleep</span></span><br><span class="line">    <span class="comment">//(waiter descriptor is dequeued by signaler)</span></span><br><span class="line">    s := acquireSudog()</span><br><span class="line">    root := semtable.rootFor(addr)</span><br><span class="line">    t0 := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">    s.releasetime = <span class="number">0</span></span><br><span class="line">    s.acquiretime = <span class="number">0</span></span><br><span class="line">    s.ticket = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> profile&amp;semaBlockProfile != <span class="number">0</span> &amp;&amp; blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t0 = cputicks()</span><br><span class="line">        s.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> profile&amp;semaMutexProfile != <span class="number">0</span> &amp;&amp; mutexprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> t0 == <span class="number">0</span> &#123;</span><br><span class="line">            t0 = cputicks()</span><br><span class="line">        &#125;</span><br><span class="line">        s.acquiretime = t0</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lockWithRank(&amp;root.lock, lockRankRoot)</span><br><span class="line">        <span class="comment">// 当前等待数量+1</span></span><br><span class="line">        root.nwait.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 尝试获取信号量</span></span><br><span class="line">        <span class="keyword">if</span> cansemacquire(addr) &#123;</span><br><span class="line">            root.nwait.Add(<span class="number">-1</span>)</span><br><span class="line">            unlock(&amp;root.lock)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        root.queue(addr, s, lifo)</span><br><span class="line">        <span class="comment">// 当前协程等待，让调度起调用其他的协程</span></span><br><span class="line">        goparkunlock(&amp;root.lock, reason, traceBlockSync, <span class="number">4</span>+skipframes)</span><br><span class="line">        <span class="keyword">if</span> s.ticket != <span class="number">0</span> || cansemacquire(addr) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> s.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">        blockevent(s.releasetime-t0, <span class="number">3</span>+skipframes)</span><br><span class="line">    &#125;</span><br><span class="line">    releaseSudog(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>runtime_SemacquireMutex</code>函数的作用就是使用使用信号量保证资源不会被两个协程获取</p><h3 id="4-解锁"><a href="#4-解锁" class="headerlink" title="4 解锁"></a>4 解锁</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock() &#123;</span><br><span class="line">    <span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">        _ = m.state</span><br><span class="line">        race.Release(unsafe.Pointer(m))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 快速解锁</span></span><br><span class="line">    <span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 不等于0，代表快速解锁失败，开始慢速解锁</span></span><br><span class="line">        m.unlockSlow(<span class="built_in">new</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> unlockSlow(<span class="built_in">new</span> <span class="type">int32</span>) &#123;</span><br><span class="line">    <span class="comment">// 已经被解锁，则直接抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常模式</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">        old := <span class="built_in">new</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// 没有阻塞的协程，直接返回</span></span><br><span class="line">            <span class="comment">// 有阻塞的协程但是从处于mutexWoken或者已经被上锁或者处于饥饿模式，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 唤醒一个协程，阻塞数量减1，并将mutexWoken置为true</span></span><br><span class="line">            <span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">            <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">                runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            old = m.state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 饥饿模式，直接将锁交给下一个等待者</span></span><br><span class="line">        runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>slice源码学习</title>
      <link href="/2023/09/01/slice%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/09/01/slice%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>特别提醒，本文所涉及的源码是<code>go1.21.0 darwin/amd64</code><br>文件位置：runtime/slice.go</p></blockquote><h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1 数据结构"></a>1 数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>array：指向存储元素内存空间的起始地点</li><li>len：切片的长度</li><li>cap：切片的容量</li></ul><h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2 初始化"></a>2 初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice</span><span class="params">(et *_type, <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// 判断分配的内存是否会溢出</span></span><br><span class="line">    mem, overflow := math.MulUintptr(et.Size_, <span class="type">uintptr</span>(<span class="built_in">cap</span>))</span><br><span class="line">    <span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> || <span class="built_in">len</span> &gt; <span class="built_in">cap</span> &#123;</span><br><span class="line">        mem, overflow := math.MulUintptr(et.Size_, <span class="type">uintptr</span>(<span class="built_in">len</span>))</span><br><span class="line">        <span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> &#123;</span><br><span class="line">            panicmakeslicelen()</span><br><span class="line">        &#125;</span><br><span class="line">        panicmakeslicecap()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="keyword">return</span> mallocgc(mem, et, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-扩容"><a href="#3-扩容" class="headerlink" title="3 扩容"></a>3 扩容</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(oldPtr unsafe.Pointer, newLen, oldCap, num <span class="type">int</span>, et *_type)</span></span> slice &#123;</span><br><span class="line">    <span class="comment">// 旧切片的长度</span></span><br><span class="line">    oldLen := newLen - num</span><br><span class="line">    <span class="keyword">if</span> newLen &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(errorString(<span class="string">&quot;growslice: len out of range&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 元素大小为0，则直接分配</span></span><br><span class="line">    <span class="keyword">if</span> et.Size_ == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// append should not create a slice with nil pointer but non-zero len.</span></span><br><span class="line">        <span class="comment">// We assume that append doesn&#x27;t need to preserve oldPtr in this case.</span></span><br><span class="line">        <span class="keyword">return</span> slice&#123;unsafe.Pointer(&amp;zerobase), newLen, newLen&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断新切片的容量大小</span></span><br><span class="line">    newcap := oldCap</span><br><span class="line">    doublecap := newcap + newcap</span><br><span class="line">    <span class="comment">// 如果新切片的长度大于旧切片容量的两倍，则将新切片的长度赋值给容量</span></span><br><span class="line">    <span class="keyword">if</span> newLen &gt; doublecap &#123;</span><br><span class="line">        newcap = newLen</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> threshold = <span class="number">256</span></span><br><span class="line">        <span class="comment">// 旧切片的容量小于256</span></span><br><span class="line">        <span class="keyword">if</span> oldCap &lt; threshold &#123;</span><br><span class="line">            <span class="comment">// 两倍扩容</span></span><br><span class="line">            newcap = doublecap</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 一直增加，直到大于切片的长度</span></span><br><span class="line">            <span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; newLen &#123;</span><br><span class="line">                <span class="comment">// 扩容速度为1/4的原来容量+固定值192</span></span><br><span class="line">                newcap += (newcap + <span class="number">3</span>*threshold) / <span class="number">4</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 超过int32类型大小，则将长度赋值给容量</span></span><br><span class="line">            <span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">                newcap = newLen</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> overflow <span class="type">bool</span></span><br><span class="line">    <span class="keyword">var</span> lenmem, newlenmem, capmem <span class="type">uintptr</span></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> et.Size_ == <span class="number">1</span>:<span class="comment">// 元素大小为1</span></span><br><span class="line">        lenmem = <span class="type">uintptr</span>(oldLen)</span><br><span class="line">        newlenmem = <span class="type">uintptr</span>(newLen)</span><br><span class="line">        capmem = roundupsize(<span class="type">uintptr</span>(newcap))</span><br><span class="line">        overflow = <span class="type">uintptr</span>(newcap) &gt; maxAlloc</span><br><span class="line">        newcap = <span class="type">int</span>(capmem)</span><br><span class="line">    <span class="keyword">case</span> et.Size_ == goarch.PtrSize:<span class="comment">// 元素是指针类型</span></span><br><span class="line">        lenmem = <span class="type">uintptr</span>(oldLen) * goarch.PtrSize</span><br><span class="line">        newlenmem = <span class="type">uintptr</span>(newLen) * goarch.PtrSize</span><br><span class="line">        capmem = roundupsize(<span class="type">uintptr</span>(newcap) * goarch.PtrSize)</span><br><span class="line">        overflow = <span class="type">uintptr</span>(newcap) &gt; maxAlloc/goarch.PtrSize</span><br><span class="line">        newcap = <span class="type">int</span>(capmem / goarch.PtrSize)</span><br><span class="line">    <span class="keyword">case</span> isPowerOfTwo(et.Size_):<span class="comment">// 元素大小是2的幂</span></span><br><span class="line">        <span class="keyword">var</span> shift <span class="type">uintptr</span></span><br><span class="line">        <span class="keyword">if</span> goarch.PtrSize == <span class="number">8</span> &#123;</span><br><span class="line">            shift = <span class="type">uintptr</span>(sys.TrailingZeros64(<span class="type">uint64</span>(et.Size_))) &amp; <span class="number">63</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            shift = <span class="type">uintptr</span>(sys.TrailingZeros32(<span class="type">uint32</span>(et.Size_))) &amp; <span class="number">31</span></span><br><span class="line">        &#125;<span class="comment">// 通过移位操作，性能更高效</span></span><br><span class="line">        lenmem = <span class="type">uintptr</span>(oldLen) &lt;&lt; shift</span><br><span class="line">        newlenmem = <span class="type">uintptr</span>(newLen) &lt;&lt; shift</span><br><span class="line">        capmem = roundupsize(<span class="type">uintptr</span>(newcap) &lt;&lt; shift)</span><br><span class="line">        overflow = <span class="type">uintptr</span>(newcap) &gt; (maxAlloc &gt;&gt; shift)</span><br><span class="line">        newcap = <span class="type">int</span>(capmem &gt;&gt; shift)</span><br><span class="line">        capmem = <span class="type">uintptr</span>(newcap) &lt;&lt; shift</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        lenmem = <span class="type">uintptr</span>(oldLen) * et.Size_</span><br><span class="line">        newlenmem = <span class="type">uintptr</span>(newLen) * et.Size_</span><br><span class="line">        capmem, overflow = math.MulUintptr(et.Size_, <span class="type">uintptr</span>(newcap))</span><br><span class="line">        capmem = roundupsize(capmem)</span><br><span class="line">        newcap = <span class="type">int</span>(capmem / et.Size_)</span><br><span class="line">        capmem = <span class="type">uintptr</span>(newcap) * et.Size_</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> overflow || capmem &gt; maxAlloc &#123;</span><br><span class="line">        <span class="built_in">panic</span>(errorString(<span class="string">&quot;growslice: len out of range&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新的内存地址</span></span><br><span class="line">    <span class="keyword">var</span> p unsafe.Pointer</span><br><span class="line">    <span class="keyword">if</span> et.PtrBytes == <span class="number">0</span> &#123;<span class="comment">// 无指针</span></span><br><span class="line">        p = mallocgc(capmem, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">        memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 有指针</span></span><br><span class="line">        p = mallocgc(capmem, et, <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">if</span> lenmem &gt; <span class="number">0</span> &amp;&amp; writeBarrier.enabled &#123;</span><br><span class="line">            bulkBarrierPreWriteSrcOnly(<span class="type">uintptr</span>(p), <span class="type">uintptr</span>(oldPtr), lenmem-et.Size_+et.PtrBytes)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memmove(p, oldPtr, lenmem)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slice&#123;p, newLen, newcap&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容规则：</p><ol><li>如果新切片的长度大于旧切片容量的两倍，则直接将新切片的长度作为容量</li><li>容量小于256，直接两倍扩容</li><li>大于256，则循环扩容加上1/4容量和一个固定值192，</li></ol><h3 id="4-切片拷贝"><a href="#4-切片拷贝" class="headerlink" title="4 切片拷贝"></a>4 切片拷贝</h3><h4 id="4-1-赋值拷贝"><a href="#4-1-赋值拷贝" class="headerlink" title="4.1 赋值拷贝"></a>4.1 赋值拷贝</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">s2 := s1[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure><p>这种通过赋值来拷贝的，两者会共用一个底层数组，意思就是两者指向的元素是相同的，即</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230901214335034.png" alt="image-20230901214335034" style="zoom:40%;" /></p><h4 id="4-2-copy或者slicecopy"><a href="#4-2-copy或者slicecopy" class="headerlink" title="4.2 copy或者slicecopy"></a>4.2 copy或者slicecopy</h4><p>如果不想要两个指向的同一个数组，则通过<code>copy</code>或者<code>slicecopy</code>来进行拷贝，两种拷贝方式都会通过 <code>runtime.memmove</code>将整块内存的内容拷贝到目标的内存区域中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicecopy</span><span class="params">(toPtr unsafe.Pointer, toLen <span class="type">int</span>, fromPtr unsafe.Pointer, fromLen <span class="type">int</span>, width <span class="type">uintptr</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fromLen == <span class="number">0</span> || toLen == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    n := fromLen</span><br><span class="line">    <span class="keyword">if</span> toLen &lt; n &#123;</span><br><span class="line">        n = toLen</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> width == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">1</span> &#123; <span class="comment">// common case worth about 2x to do here</span></span><br><span class="line">        *(*<span class="type">byte</span>)(toPtr) = *(*<span class="type">byte</span>)(fromPtr) <span class="comment">// known to be a byte pointer</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        memmove(toPtr, fromPtr, size)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230901214757321.png" alt="image-20230901214757321" style="zoom:40%;" /></p><h3 id="5-追加和删除"><a href="#5-追加和删除" class="headerlink" title="5 追加和删除"></a>5 追加和删除</h3><p>追加操作比较简单通过<code>append()</code>即可实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;  </span><br><span class="line">s = <span class="built_in">append</span>(s,<span class="number">5</span>)<span class="comment">// [2,3,4,5]</span></span><br></pre></td></tr></table></figure><p>删除操作有如下几种情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">s = s[<span class="number">1</span>:]<span class="comment">// [1,2,3,4]</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">append</span>(s[:<span class="number">2</span>],s[<span class="number">3</span>:]...)<span class="comment">// [0,1,3,4]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map源码学习</title>
      <link href="/2023/09/01/map%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/09/01/map%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>特别提醒，本文所涉及的源码是<code>go1.21.0 darwin/amd64</code></p><p>文件位置：runtime/map.go</p><p>哈希表作为一种非常常见的数据结构，在其它语言中也都会有出现，因此本文不对哈希表的概念、用法做解释，专注于go语言中的源码学习。</p></blockquote><h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1 数据结构"></a>1 数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count     <span class="type">int</span> <span class="comment">// 当前map中的元素数量</span></span><br><span class="line">    flags     <span class="type">uint8</span></span><br><span class="line">    B         <span class="type">uint8</span> </span><br><span class="line">    noverflow <span class="type">uint16</span> </span><br><span class="line">    hash0     <span class="type">uint32</span> <span class="comment">// 哈希种子，在创建map时得到的一个随机数</span></span><br><span class="line">    buckets    unsafe.Pointer <span class="comment">// 桶数组</span></span><br><span class="line">    oldbuckets unsafe.Pointer <span class="comment">// 扩容过程中旧的桶数组</span></span><br><span class="line">    nevacuate  <span class="type">uintptr</span>        </span><br><span class="line">    extra *mapextra <span class="comment">// 额外记录的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>flags：标志位<ul><li>iterator = 1：可能有迭代器在遍历<code>buckets</code></li><li>oldIterator  = 2：可能有迭代器在遍历<code>oldbuckets</code>，用于扩容期间</li><li>hashWriting  = 4：标记一个<code>g</code>正在写<code>map</code></li><li>sameSizeGrow = 8：等量扩容</li></ul></li><li>B：桶数量的指数，即<code>len(buckets)</code>$=2^B$</li><li><p>noverflow：溢出同的数量，当其接近$2^{15}-1$时为近似值</p></li><li><p>nevacuate：扩容过程中的进度标识（index小于它的桶已经被转移到新桶中了）</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">    overflow    *[]*bmap</span><br><span class="line">    oldoverflow *[]*bmap</span><br><span class="line">    nextOverflow *bmap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>map</code>中的<code>kev</code>和<code>value</code>不包含指针时，<code>overflow</code>和<code>oldoverflow</code>才被使用</p><ul><li>overflow：<code>hmap.buckets</code> 使用的溢出桶</li><li>oldoverflow：<code>hmap.oldbuckets</code>使用的溢出桶</li><li>nextOverflow：下一个可以用的溢出桶</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// bucketCnt=8</span></span><br><span class="line">    tophash [bucketCnt]<span class="type">uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>tophash： $\leq5$时存放的是状态。$\gt5$时存放的是高8位的<code>hash</code>值，用于快速判断<code>key</code>是否存在<ul><li>emptyRest = 0： 此单元为空，且更高索引的单元也为空</li><li>emptyOne = 1： 此单元为空</li><li>evacuatedX = 2： 用于表示扩容迁移到新桶前半段区间，即索引没变</li><li>evacuatedY = 3： 用于表示扩容迁移到新桶后半段区间，即在新桶中的索引=旧桶索引+扩容前容量大小</li><li>evacuatedEmpty = 4： 用于表示此桶已迁移完成</li><li>minTopHash = 5： 最小的空桶标记值，小于其则是空桶标志</li></ul></li></ul><p>在<code>runtime/map.go</code>文件中<code>bmap</code>只包含了一个简单的<code>tophash</code>字段，但是在运行期间会根据<code>key</code>和<code>value</code>的类型对<code>bmap</code>的结构进行重建如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    topbits  [<span class="number">8</span>]<span class="type">uint8</span></span><br><span class="line">    keys     [<span class="number">8</span>]keytype</span><br><span class="line">    elems    [<span class="number">8</span>]elemype</span><br><span class="line">    overflow <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>相关代码在：cmd/compile/internal/reflectdata/reflect.go:   MapBucketType</p></blockquote><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230831164229965.png" alt="image-20230831164229965"></p><h3 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2 构造方法"></a>2 构造方法</h3><p>创建<code>map</code>时，实际上会调用<code>makemap()</code>方法，该方法分析如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="type">int</span>, h *hmap)</span></span> *hmap</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mem, overflow := math.MulUintptr(<span class="type">uintptr</span>(hint), t.Bucket.Size_)</span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc &#123;</span><br><span class="line">    hint = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hint</code>是为<code>map</code>拟分配的容量，再分配前会对拟分配的内存大小进行判断，如果超过限制大小，则会将<code>hint</code>设置为零</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">    h = <span class="built_in">new</span>(hmap)</span><br><span class="line">&#125;</span><br><span class="line">h.hash0 = fastrand()</span><br></pre></td></tr></table></figure><p>初始化<code>h</code>，并设置哈希种子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">B := <span class="type">uint8</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> overLoadFactor(hint, B) &#123;</span><br><span class="line">    B++</span><br><span class="line">&#125;</span><br><span class="line">h.B = B</span><br></pre></td></tr></table></figure><p>首先初始化<code>B</code>为0，然后根据$\frac{hint}{6}&gt;2^B$如果成立则B+1，最后直到B不成立为止，即让$\frac{hint}{2^B}$负载因子小于等于6</p><p>map 预分配容量、桶数组长度指数、桶数组长度之间的关系如下表：</p><div class="table-container"><table><thead><tr><th>kv对数量</th><th>指数B</th><th>长度$2^B$</th></tr></thead><tbody><tr><td>0~8</td><td>0</td><td>1</td></tr><tr><td>9~12</td><td>1</td><td>2</td></tr><tr><td>13~24</td><td>2</td><td>4</td></tr><tr><td>25~48</td><td>3</td><td>8</td></tr><tr><td>$2^{B-1}\times6+1$~$ 2^B \times 6$</td><td>B</td><td>$2^B$</td></tr></tbody></table></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> h.B != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nextOverflow *bmap</span><br><span class="line">    h.buckets, nextOverflow = makeBucketArray(t, h.B, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">        h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">        h.extra.nextOverflow = nextOverflow</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>makeBucketArray</code>初始化桶数组<code>buckets</code>，如果<code>map</code>容量过大，会提前申请溢出桶</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeBucketArray</span><span class="params">(t *maptype, b <span class="type">uint8</span>, dirtyalloc unsafe.Pointer)</span></span> (buckets unsafe.Pointer, nextOverflow *bmap) &#123;</span><br><span class="line">    base := bucketShift(b)</span><br><span class="line">    nbuckets := base</span><br><span class="line">    <span class="keyword">if</span> b &gt;= <span class="number">4</span> &#123;</span><br><span class="line">        nbuckets += bucketShift(b - <span class="number">4</span>)</span><br><span class="line">        sz := t.Bucket.Size_ * nbuckets</span><br><span class="line">        up := roundupsize(sz)</span><br><span class="line">        <span class="keyword">if</span> up != sz &#123;</span><br><span class="line">            nbuckets = up / t.Bucket.Size_</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> dirtyalloc == <span class="literal">nil</span> &#123;</span><br><span class="line">        buckets = newarray(t.Bucket, <span class="type">int</span>(nbuckets))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buckets = dirtyalloc</span><br><span class="line">        size := t.Bucket.Size_ * nbuckets</span><br><span class="line">        <span class="keyword">if</span> t.Bucket.PtrBytes != <span class="number">0</span> &#123;</span><br><span class="line">            memclrHasPointers(buckets, size)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            memclrNoHeapPointers(buckets, size)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> base != nbuckets &#123;</span><br><span class="line">        nextOverflow = (*bmap)(add(buckets, base*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">        last := (*bmap)(add(buckets, (nbuckets<span class="number">-1</span>)*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">        last.setoverflow(t, (*bmap)(buckets))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buckets, nextOverflow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>B</code>大于4的话，会额外多创建$2^{B-4}$个溢出桶（内存对齐），并将<code>h.nextOverflow</code>指向第一个溢出桶的地址，最后一个溢出桶的地址设置为<code>h.buckets</code>(方便判断溢出桶已经用完)</p><h3 id="3-读操作"><a href="#3-读操作" class="headerlink" title="3 读操作"></a>3 读操作</h3><p><code>map</code>的读操作一般是通过下标或者遍历进行的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">value = hash[key]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> hash &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种方式都能够读取，但是所使用到的函数和底层的原理是不同的</p><h4 id="3-1-通过key来读取"><a href="#3-1-通过key来读取" class="headerlink" title="3.1 通过key来读取"></a>3.1 通过key来读取</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value := hash[key]<span class="comment">// =&gt; v     := mapaccess1(maptype, hash, &amp;key)</span></span><br><span class="line">value,ok := hash[key]<span class="comment">// =&gt; v, ok := mapaccess2(maptype, hash, &amp;key)</span></span><br></pre></td></tr></table></figure><ul><li>当只需要一个返回值时，会调用<code>mapaccess1()</code>函数</li><li>当需要两个返回值时，会调用<code>mapaccess2()</code>函数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t.HashMightPanic() &#123;</span><br><span class="line">        t.Hasher(key, <span class="number">0</span>) <span class="comment">// see issue 23734</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1 如果<code>h</code>未初始化或者<code>map</code>中的<code>k-v</code>对为0，则会直接返回一个零值对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">    fatal(<span class="string">&quot;concurrent map read and map write&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 如果此时有其它的<code>g</code>在对<code>map</code>进行写操作，则直接返回<code>fatal</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hash := t.Hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">m := bucketMask(h.B)</span><br><span class="line">b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="type">uintptr</span>(t.BucketSize)))</span><br></pre></td></tr></table></figure><p>3 通过<code>MapType.Hasher()</code>方法得到<code>key</code>对应的<code>hash</code>值并对桶数量取模，获取对应桶的索引</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">        <span class="comment">// There used to be half as many buckets; mask down one more power of two.</span></span><br><span class="line">        m &gt;&gt;= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    oldb := (*bmap)(add(c, (hash&amp;m)*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">    <span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">        b = oldb</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4 判断<code>map</code>是否正在扩容，首先判断是否进行增量扩容，倘若是的话，需要将m除以2，因为旧桶的长度只是新桶的一半，然后通过<code>evacuated</code>判断要找的桶是否在旧的桶数组里面，如果是则需要去旧的桶数组当中去找。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">top := tophash(hash)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tophash</span><span class="params">(hash <span class="type">uintptr</span>)</span></span> <span class="type">uint8</span> &#123;</span><br><span class="line">    top := <span class="type">uint8</span>(hash &gt;&gt; (goarch.PtrSize*<span class="number">8</span> - <span class="number">8</span>))</span><br><span class="line">    <span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">        top += minTopHash</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5 获取<code>hash</code>值的高八位，如果该值小于5，会加上5，以避开0~4这个区间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">bucketloop:</span><br><span class="line">    <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">                <span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">                    <span class="keyword">break</span> bucketloop</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">            <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                k = *((*unsafe.Pointer)(k))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> t.Key.Equal(key, k) &#123;</span><br><span class="line">                e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.KeySize)+i*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">                <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">                    e = *((*unsafe.Pointer)(e))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> e</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>6 外层<code>for</code>循环会遍历要查找的那个桶及其后续的溢出桶，里层<code>for</code>循环遍历桶内的<code>key-value</code>对。遍历时首先查询高8位的<code>tophash</code>值，如果和<code>key</code>的对应不上，并且当前位置的<code>tophash</code>为0，则后面没有元素，直接结束这个桶的遍历。倘若找到了相等的<code>key</code>，则通过地址偏移的方式取到 <code>value</code> 并返回，如果遍历了所有桶都没找到，则返回一个零值。</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230829203844637.png" alt="image-20230829203844637" style="zoom:40%;" /></p><h3 id="4-写操作"><a href="#4-写操作" class="headerlink" title="4 写操作"></a>4 写操作</h3><p>写操作的实现由<code>mapassign</code>函数实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回待更新的value地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    hash := t.hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">    <span class="comment">// 桶为空，则分配一个桶</span></span><br><span class="line">    <span class="keyword">if</span> h.buckets == <span class="literal">nil</span> &#123;</span><br><span class="line">        h.buckets = newobject(t.bucket) <span class="comment">// newarray(t.bucket, 1)</span></span><br><span class="line">    &#125;</span><br><span class="line">again:</span><br><span class="line">    bucket := hash &amp; bucketMask(h.B)<span class="comment">//获取目标桶序号</span></span><br><span class="line">    <span class="comment">// 如果还处于扩容中，我们要让这个key对应的旧桶立马迁移到新桶</span></span><br><span class="line">    <span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">        growWork(t, h, bucket)<span class="comment">//见扩容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// b就是目标桶</span></span><br><span class="line">    b := (*bmap)(add(h.buckets, bucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">  top := tophash(hash)<span class="comment">//hash高8位</span></span><br><span class="line">    <span class="keyword">var</span> inserti *<span class="type">uint8</span><span class="comment">//tophash</span></span><br><span class="line">    <span class="keyword">var</span> insertk unsafe.Pointer<span class="comment">//key</span></span><br><span class="line">    <span class="keyword">var</span> elem unsafe.Pointer<span class="comment">//value</span></span><br><span class="line">bucketloop:</span><br><span class="line">    <span class="comment">// 外循环是遍历桶，内循环是遍历每个桶的8个kv对</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">                <span class="comment">// 找到了第一个空的存放地址</span></span><br><span class="line">                <span class="keyword">if</span> isEmpty(b.tophash[i]) &amp;&amp; inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">                    inserti = &amp;b.tophash[i]</span><br><span class="line">                    insertk = add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">                    elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果后续的所有cell都是空的了，没必要再查询</span></span><br><span class="line">                <span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">                    <span class="keyword">break</span> bucketloop</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">            <span class="comment">// tophash相同后，再比较key进行确认</span></span><br><span class="line">            <span class="keyword">if</span> !t.key.equal(key, k) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//并将待更新的value地址返回</span></span><br><span class="line">            elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">            <span class="keyword">goto</span> done</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取下一个溢出桶</span></span><br><span class="line">        ovf := b.overflow(t)</span><br><span class="line">        <span class="keyword">if</span> ovf == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        b = ovf</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面就是map没有存key的情况</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当不处于扩容时，超过负载因子或者太多溢出桶，即溢出桶个数大于等于1&lt;&lt; min(h.B,15)</span></span><br><span class="line">    <span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">        hashGrow(t, h)<span class="comment">// 分配新桶，但还不迁移旧桶，见扩容部分</span></span><br><span class="line">        <span class="keyword">goto</span> again </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没找到任何空位</span></span><br><span class="line">    <span class="keyword">if</span> inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 从溢出桶池拿或者分配溢出桶内存，见下文</span></span><br><span class="line">        newb := h.newoverflow(t, b)</span><br><span class="line">        inserti = &amp;newb.tophash[<span class="number">0</span>]</span><br><span class="line">        insertk = add(unsafe.Pointer(newb), dataOffset)</span><br><span class="line">        elem = add(insertk, bucketCnt*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">    &#125;</span><br><span class="line">    *inserti = top<span class="comment">// 设置tophash</span></span><br><span class="line">    h.count++<span class="comment">// map元素数量+1</span></span><br><span class="line">done:</span><br><span class="line">    <span class="keyword">return</span> elem<span class="comment">//将存取value的地址返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230831170342743.png" alt="image-20230831170342743" style="zoom:40%;" /></p><h3 id="5-删除操作"><a href="#5-删除操作" class="headerlink" title="5 删除操作"></a>5 删除操作</h3><p><code>map</code>相关的删除操作在<code>mapdelete()</code>函数下面，与更新操作类似，多了一个修改当前<code>tophash</code>状态的步骤</p><p>首先会将当前的<code>tophash[i]</code>更新为<code>emptyOne</code>，这个不仅仅是操作自己的<code>tophash[i]</code>还要判断它的下一个是不是<code>emptyRest</code>，如果下一个为<code>emptyRest</code>，那么就可以将<code>tophash[i]</code>进一步更新为<code>emptyRest</code>，并且还需要判断之前的<code>tophash</code>如果之前的为<code>emptyOne</code>则要修改为<code>emptyRest</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapdelete</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> &#123;</span><br><span class="line">  <span class="comment">// h为空，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> t.HashMightPanic() &#123;</span><br><span class="line">            t.Hasher(key, <span class="number">0</span>) <span class="comment">// see issue 23734</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 当前有goroutine在写，则返回fatal</span></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    hash := t.Hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">    h.flags ^= hashWriting</span><br><span class="line">    <span class="comment">// 找到对应的桶</span></span><br><span class="line">    bucket := hash &amp; bucketMask(h.B)</span><br><span class="line">  <span class="comment">// 正在扩容，先协助迁移，再删除</span></span><br><span class="line">    <span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">        growWork(t, h, bucket)</span><br><span class="line">    &#125;</span><br><span class="line">    b := (*bmap)(add(h.buckets, bucket*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">    bOrig := b</span><br><span class="line">    top := tophash(hash)</span><br><span class="line">search:</span><br><span class="line">    <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">                <span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">                    <span class="keyword">break</span> search</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">            k2 := k</span><br><span class="line">            <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                k2 = *((*unsafe.Pointer)(k2))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> !t.Key.Equal(key, k2) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Only clear key if there are pointers in it.</span></span><br><span class="line">            <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                *(*unsafe.Pointer)(k) = <span class="literal">nil</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> t.Key.PtrBytes != <span class="number">0</span> &#123;</span><br><span class="line">                memclrHasPointers(k, t.Key.Size_)</span><br><span class="line">            &#125;</span><br><span class="line">            e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.KeySize)+i*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">            <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">                *(*unsafe.Pointer)(e) = <span class="literal">nil</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> t.Elem.PtrBytes != <span class="number">0</span> &#123;</span><br><span class="line">                memclrHasPointers(e, t.Elem.Size_)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                memclrNoHeapPointers(e, t.Elem.Size_)</span><br><span class="line">            &#125;</span><br><span class="line">      <span class="comment">// 更新状态</span></span><br><span class="line">            b.tophash[i] = emptyOne</span><br><span class="line">      <span class="comment">// 没有后一个kv对或者后一个kv对是emptyOne状态，不需要进一步更新状态</span></span><br><span class="line">            <span class="keyword">if</span> i == bucketCnt<span class="number">-1</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> b.overflow(t) != <span class="literal">nil</span> &amp;&amp; b.overflow(t).tophash[<span class="number">0</span>] != emptyRest &#123;</span><br><span class="line">                    <span class="keyword">goto</span> notLast</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> b.tophash[i+<span class="number">1</span>] != emptyRest &#123;</span><br><span class="line">                    <span class="keyword">goto</span> notLast</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> &#123; <span class="comment">// 从后往前，将之前的emptyOne都改为emptyRest</span></span><br><span class="line">                b.tophash[i] = emptyRest</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> b == bOrig &#123;</span><br><span class="line">                        <span class="keyword">break</span> <span class="comment">// beginning of initial bucket, we&#x27;re done.</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    c := b</span><br><span class="line">                    <span class="keyword">for</span> b = bOrig; b.overflow(t) != c; b = b.overflow(t) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    i = bucketCnt - <span class="number">1</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i--</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> b.tophash[i] != emptyOne &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        notLast:</span><br><span class="line">            h.count--</span><br><span class="line">            <span class="keyword">if</span> h.count == <span class="number">0</span> &#123;</span><br><span class="line">                h.hash0 = fastrand()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span> search</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting == <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    h.flags &amp;^= hashWriting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-扩容操作"><a href="#6-扩容操作" class="headerlink" title="6 扩容操作"></a>6 扩容操作</h3><ul><li>等量扩容：负载因子没超过6，但是溢出桶的数量大于等于$1&lt;&lt;min(B,15)$，新桶数组的长度跟旧的一样，相当于是将<code>k-v</code>对重新<code>hash</code></li><li>增量扩容：负载因子超过6，新桶数组的长度是旧的两倍</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashGrow</span><span class="params">(t *maptype, h *hmap)</span></span> &#123;</span><br><span class="line">    bigger := <span class="type">uint8</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 如果是等量扩容</span></span><br><span class="line">    <span class="keyword">if</span> !overLoadFactor(h.count+<span class="number">1</span>, h.B) &#123;</span><br><span class="line">        bigger = <span class="number">0</span></span><br><span class="line">        h.flags |= sameSizeGrow</span><br><span class="line">    &#125;</span><br><span class="line">    oldbuckets := h.buckets</span><br><span class="line">    <span class="comment">// 增量扩容中新桶变为旧桶两倍，等量扩容是数量不变</span></span><br><span class="line">    newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, <span class="literal">nil</span>)</span><br><span class="line">    flags := h.flags &amp;^ (iterator | oldIterator)</span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &#123;</span><br><span class="line">        flags |= oldIterator</span><br><span class="line">    &#125;</span><br><span class="line">    h.B += bigger</span><br><span class="line">    h.flags = flags</span><br><span class="line">    h.oldbuckets = oldbuckets</span><br><span class="line">    h.buckets = newbuckets</span><br><span class="line">    h.nevacuate = <span class="number">0</span></span><br><span class="line">    h.noverflow = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> h.extra != <span class="literal">nil</span> &amp;&amp; h.extra.overflow != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> h.extra.oldoverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;oldoverflow is not nil&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        h.extra.oldoverflow = h.extra.overflow</span><br><span class="line">        h.extra.overflow = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> h.extra == <span class="literal">nil</span> &#123;</span><br><span class="line">            h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">        &#125;</span><br><span class="line">        h.extra.nextOverflow = nextOverflow</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的逻辑还是比较简单，并且<code>hashGrow</code>只在<code>mapassign</code>中出现，就是说只有在新值插入的时候才可能触发扩容。</p><p>下面来分析<code>growWork()</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growWork</span><span class="params">(t *maptype, h *hmap, bucket <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 迁移指定的旧桶</span></span><br><span class="line">    evacuate(t, h, bucket&amp;h.oldbucketmask())</span><br><span class="line">    <span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">    <span class="comment">// 额外再迁移一个桶</span></span><br><span class="line">    <span class="comment">// nevacuate就是记录迁移的进度，所有序号小于这个的桶都已经迁移</span></span><br><span class="line">        evacuate(t, h, h.nevacuate)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为使用的是渐进式扩容，因此在插入和删除操作中，如果此时<code>map</code>正在扩容，则每一个操作都会利用<code>growWork()</code>函数迁移最多两个桶，一个是当时操作的桶，还有一个就是<code>nevacuate</code>指向的桶，另外要注意的是这里的一个桶是包括它所指向的溢出桶的。具体的迁移逻辑在<code>evacuate()</code>函数中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代表了kv对的迁移目的地</span></span><br><span class="line"><span class="keyword">type</span> evacDst <span class="keyword">struct</span> &#123;</span><br><span class="line">    b *bmap          <span class="comment">// 迁移到的目的桶</span></span><br><span class="line">    i <span class="type">int</span>            <span class="comment">// 迁移到的kv对在桶内的序号</span></span><br><span class="line">    k unsafe.Pointer <span class="comment">// 迁移到的kv对的key位置</span></span><br><span class="line">    e unsafe.Pointer <span class="comment">// 迁移到的kv对的value位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// oldbucket表示要迁移的桶序号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evacuate</span><span class="params">(t *maptype, h *hmap, oldbucket <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    b := (*bmap)(add(h.oldbuckets, oldbucket*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">    newbit := h.noldbuckets()<span class="comment">// 旧桶个数</span></span><br><span class="line">    <span class="keyword">if</span> !evacuated(b) &#123;</span><br><span class="line">        <span class="keyword">var</span> xy [<span class="number">2</span>]evacDst<span class="comment">// 新桶的前一半和后一半</span></span><br><span class="line">        x := &amp;xy[<span class="number">0</span>]</span><br><span class="line">        x.b = (*bmap)(add(h.buckets, oldbucket*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">        x.k = add(unsafe.Pointer(x.b), dataOffset)</span><br><span class="line">        x.e = add(x.k, bucketCnt*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">        <span class="comment">// 增量扩容，有后一半</span></span><br><span class="line">        <span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">            y := &amp;xy[<span class="number">1</span>]</span><br><span class="line">            y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">            y.k = add(unsafe.Pointer(y.b), dataOffset)</span><br><span class="line">            y.e = add(y.k, bucketCnt*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前面已经将要迁移到的位置记录下来</span></span><br><span class="line">        <span class="comment">// 将这个桶及其溢出桶都迁移</span></span><br><span class="line">        <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset)</span><br><span class="line">            e := add(k, bucketCnt*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; bucketCnt; i, k, e = i+<span class="number">1</span>, add(k, <span class="type">uintptr</span>(t.KeySize)), add(e, <span class="type">uintptr</span>(t.ValueSize)) &#123;</span><br><span class="line">                top := b.tophash[i]</span><br><span class="line">                <span class="comment">// 当前位置已完成迁移，状态置为evacuatedEmpty</span></span><br><span class="line">                <span class="keyword">if</span> isEmpty(top) &#123;</span><br><span class="line">                    b.tophash[i] = evacuatedEmpty</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">                    throw(<span class="string">&quot;bad map state&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                k2 := k</span><br><span class="line">                <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                    k2 = *((*unsafe.Pointer)(k2))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">var</span> useY <span class="type">uint8</span></span><br><span class="line">                <span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">                    hash := t.Hasher(k2, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">                    <span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &amp;&amp; !t.ReflexiveKey() &amp;&amp; !t.Key.Equal(k2, k2) &#123;</span><br><span class="line">                        useY = top &amp; <span class="number">1</span></span><br><span class="line">                        top = tophash(hash)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 判断第n+1位是否等于1，后面n位跟旧桶一样</span></span><br><span class="line">                        <span class="keyword">if</span> hash&amp;newbit != <span class="number">0</span> &#123;</span><br><span class="line">                            useY = <span class="number">1</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> evacuatedX+<span class="number">1</span> != evacuatedY || evacuatedX^<span class="number">1</span> != evacuatedY &#123;</span><br><span class="line">                    throw(<span class="string">&quot;bad evacuatedN&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                b.tophash[i] = evacuatedX + useY <span class="comment">// evacuatedX + 1 == evacuatedY</span></span><br><span class="line">                dst := &amp;xy[useY]                 <span class="comment">// 迁移目的地</span></span><br><span class="line">                <span class="comment">// 目的桶8个kv对满了</span></span><br><span class="line">                <span class="keyword">if</span> dst.i == bucketCnt &#123;</span><br><span class="line">          <span class="comment">// 生成一个新的溢出桶</span></span><br><span class="line">                    dst.b = h.newoverflow(t, dst.b)</span><br><span class="line">                    dst.i = <span class="number">0</span></span><br><span class="line">                    dst.k = add(unsafe.Pointer(dst.b), dataOffset)</span><br><span class="line">                    dst.e = add(dst.k, bucketCnt*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">                &#125;</span><br><span class="line">                dst.b.tophash[dst.i&amp;(bucketCnt<span class="number">-1</span>)] = top <span class="comment">// mask dst.i as an optimization, to avoid a bounds check</span></span><br><span class="line">                <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                    *(*unsafe.Pointer)(dst.k) = k2 <span class="comment">// copy pointer</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    typedmemmove(t.Key, dst.k, k) <span class="comment">// copy elem</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">                    *(*unsafe.Pointer)(dst.e) = *(*unsafe.Pointer)(e)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    typedmemmove(t.Elem, dst.e, e)</span><br><span class="line">                &#125;</span><br><span class="line">                dst.i++</span><br><span class="line">                dst.k = add(dst.k, <span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">                dst.e = add(dst.e, <span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> h.flags&amp;oldIterator == <span class="number">0</span> &amp;&amp; t.Bucket.PtrBytes != <span class="number">0</span> &#123;</span><br><span class="line">            b := add(h.oldbuckets, oldbucket*<span class="type">uintptr</span>(t.BucketSize))</span><br><span class="line">            ptr := add(b, dataOffset)</span><br><span class="line">            n := <span class="type">uintptr</span>(t.BucketSize) - dataOffset</span><br><span class="line">            memclrHasPointers(ptr, n)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> oldbucket == h.nevacuate &#123;</span><br><span class="line">        advanceEvacuationMark(h, t, newbit)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下为什么增量扩容，旧桶只会出现在新桶的两个位置</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230831213704412.png" alt="image-20230831213704412"></p><p>迁移完<code>nevacuate</code>桶后，它会+1，这个时候可能+1的这个桶之前被迁移过了，所以需要继续往后找到一个还未没迁移的桶，该逻辑在<code>advanceEvacuationMark</code>函数中：</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230831213326389.png" alt="image-20230831213326389" style="zoom:40%;" /></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">advanceEvacuationMark</span><span class="params">(h *hmap, t *maptype, newbit <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    h.nevacuate++</span><br><span class="line">    <span class="comment">// 往后最多看1024个桶</span></span><br><span class="line">    stop := h.nevacuate + <span class="number">1024</span></span><br><span class="line">    <span class="comment">// newbit是旧桶的数量</span></span><br><span class="line">    <span class="keyword">if</span> stop &gt; newbit &#123;</span><br><span class="line">        stop = newbit</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将nevacuate指向第一个未迁移的桶</span></span><br><span class="line">    <span class="keyword">for</span> h.nevacuate != stop &amp;&amp; bucketEvacuated(t, h, h.nevacuate) &#123;</span><br><span class="line">        h.nevacuate++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果所有旧桶全部迁移完</span></span><br><span class="line">    <span class="keyword">if</span> h.nevacuate == newbit &#123; <span class="comment">// newbit == # of oldbuckets</span></span><br><span class="line">    <span class="comment">// 释放旧桶</span></span><br><span class="line">        h.oldbuckets = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> h.extra != <span class="literal">nil</span> &#123;</span><br><span class="line">            h.extra.oldoverflow = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 将迁移标志清除，结束扩容状态</span></span><br><span class="line">        h.flags &amp;^= sameSizeGrow</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>channel源码学习</title>
      <link href="/2023/08/27/channel%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/08/27/channel%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>特别提醒，本文所涉及的源码是<code>go1.21.0 darwin/amd64</code></p><p>文件位置：runtime/trace/chan.go</p></blockquote><h3 id="1-基本数据结构"><a href="#1-基本数据结构" class="headerlink" title="1 基本数据结构"></a>1 基本数据结构</h3><h4 id="1-1hchan"><a href="#1-1hchan" class="headerlink" title="1.1hchan"></a>1.1hchan</h4><p><code>Go</code>语言的<code>channel</code>在运行时使用<code>runtime.hchan</code>结构体来表示，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="type">uint</span>           <span class="comment">// 已经存放的元素个数</span></span><br><span class="line">    dataqsiz <span class="type">uint</span>           <span class="comment">// 容量</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// 存放元素的环形缓冲区</span></span><br><span class="line">    elemsize <span class="type">uint16</span><span class="comment">// 元素类型的大小</span></span><br><span class="line">    closed   <span class="type">uint32</span><span class="comment">// channel是否关闭</span></span><br><span class="line">    elemtype *_type <span class="comment">// 元素类型</span></span><br><span class="line">    sendx    <span class="type">uint</span>   <span class="comment">// channel发送操作处理的位置</span></span><br><span class="line">    recvx    <span class="type">uint</span>   <span class="comment">// channel接收操作处理的位置</span></span><br><span class="line">    recvq    waitq  <span class="comment">// 因接收而陷入阻塞的协程队列，即（ &lt;-ch ）</span></span><br><span class="line">    sendq    waitq  <span class="comment">// 因发送而陷入阻塞的协程队列，即（ ch&lt;- ）</span></span><br><span class="line"></span><br><span class="line">    lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-waitq"><a href="#1-2-waitq" class="headerlink" title="1.2 waitq"></a>1.2 waitq</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻塞的协程队列，是一个双向链表</span></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">    first *sudog<span class="comment">// 表头</span></span><br><span class="line">    last  *sudog<span class="comment">// 表尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-sudog"><a href="#1-3-sudog" class="headerlink" title="1.3 sudog"></a>1.3 sudog</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">    g *g</span><br><span class="line">    next *sudog</span><br><span class="line">    prev *sudog</span><br><span class="line">    elem unsafe.Pointer <span class="comment">// 指向数据元素 (可能指向栈)</span></span><br><span class="line">    acquiretime <span class="type">int64</span></span><br><span class="line">    releasetime <span class="type">int64</span></span><br><span class="line">    ticket      <span class="type">uint32</span></span><br><span class="line">    isSelect <span class="type">bool</span></span><br><span class="line">    success  <span class="type">bool</span></span><br><span class="line">    parent   *sudog <span class="comment">// semaRoot 二叉树</span></span><br><span class="line">    waitlink *sudog <span class="comment">// g.waiting list or semaRoot</span></span><br><span class="line">    waittail *sudog <span class="comment">// semaRoot</span></span><br><span class="line">    c        *hchan <span class="comment">// channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>sudog：对<code>goroutine</code>的封装，表示一个在等待队列中的<code>g</code></p></li><li><p>g：协程</p></li><li>next：链表的下一个节点</li><li>prev：链表的前一个节点</li><li>elem：指向数据</li><li>isSelect：表示<code>g</code>是否被选择</li><li>success：表示<code>channel</code>c 上的通信是否成功</li></ul><p>直接看数据结构的定义，可能会有点不理解，下面通过图来辅助理解</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230825143137015.png" alt="image-20230825143137015"></p><blockquote><p>图片来源:<a href="https://halfrost.com/go_channel/#toc-6">https://halfrost.com/go_channel/#toc-6</a></p></blockquote><p>其中<code>sendx</code>可能指向的是<code>5</code>边上那块还没有数据的区域，即如果执行 ch &lt;- data$，那么<code>data</code>将被存储到这块区域。</p><p>同理<code>recvx</code>指向的是<code>0</code>，如果执行<code>&lt;-ch</code>首先会得到 0，然后<code>recvx</code>会指向下一个</p><p>如果<code>buf</code>中存放的元素已经达到容量，此时还有<code>g</code>在执行发送操作给<code>ch</code>的话，即<code>ch&lt;-data</code>则会被添加到<code>sendq</code>队列中去，直到通道中的元素不再是满的。</p><p>同理<code>buf</code>是空的， 此时还有<code>g</code>在执行接收操作的话，即<code>&lt;-ch</code>则会被添加到<code>recvq</code>队列中去，直到通道中有元素。</p><h3 id="2-创建-channel"><a href="#2-创建-channel" class="headerlink" title="2 创建 channel"></a>2 创建 channel</h3><p>创建<code>channel</code>的函数有两个，原型如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan64</span><span class="params">(t *chantype, size <span class="type">int64</span>)</span></span> *hchan</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan</span><br></pre></td></tr></table></figure><p><code>makechan64</code>方法只是判断一下传入的<code>size</code>是否在<code>int32</code>范围内</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan64</span><span class="params">(t *chantype, size <span class="type">int64</span>)</span></span> *hchan &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="type">int64</span>(<span class="type">int</span>(size)) != size &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> makechan(t, <span class="type">int</span>(size))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的实现还是在<code>makechan</code>中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;</span><br><span class="line">    elem := t.Elem</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译器检查单个元素的大小不能超过64KB</span></span><br><span class="line">    <span class="keyword">if</span> elem.Size_ &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;makechan: invalid channel element type&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 检查是否对齐</span></span><br><span class="line">    <span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.Align_ &gt; maxAlign &#123;</span><br><span class="line">        throw(<span class="string">&quot;makechan: bad alignment&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓冲区大小检查，判断是否溢出</span></span><br><span class="line">    mem, overflow := math.MulUintptr(elem.Size_, <span class="type">uintptr</span>(size))</span><br><span class="line">    <span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> c *hchan</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> mem == <span class="number">0</span>:</span><br><span class="line">        <span class="comment">// 队列或者元素大小为0时</span></span><br><span class="line">        c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">        <span class="comment">// Rac 竞争检查使用这个地址进行同步操作</span></span><br><span class="line">        c.buf = c.raceaddr()</span><br><span class="line">    <span class="keyword">case</span> elem.PtrBytes == <span class="number">0</span>:</span><br><span class="line">        <span class="comment">// 元素不包含指针时，一次性分配hchan和buf的内存</span></span><br><span class="line">        c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">        c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 元素包含指针时,则分别申请hchan和buf的空间，两者无需连续</span></span><br><span class="line">        c = <span class="built_in">new</span>(hchan)</span><br><span class="line">        c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将其余字段赋初始值</span></span><br><span class="line">    c.elemsize = <span class="type">uint16</span>(elem.Size_)</span><br><span class="line">    c.elemtype = elem</span><br><span class="line">    c.dataqsiz = <span class="type">uint</span>(size)</span><br><span class="line">    lockInit(&amp;c.lock, lockRankHchan)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debugChan &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;makechan: chan=&quot;</span>, c, <span class="string">&quot;; elemsize=&quot;</span>, elem.Size_, <span class="string">&quot;; dataqsiz=&quot;</span>, size, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-发送数据"><a href="#3-发送数据" class="headerlink" title="3 发送数据"></a>3 发送数据</h3><p>发送数据的操作有两个函数<code>chansend1()</code>和<code>chansend()</code>，不过实现逻辑都在后者，所以直接看它怎么实现的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="comment">// 判断 channel 是否为nil</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceBlockForever, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">  lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先对<code>channel</code>进行检查，如果已经被<code>GC</code>回收，往一个<code>nil</code>的通道发送数据会发送阻塞。<code>gopark</code>会引发以 waitReasonChanSendNilChan 为原因的休眠，并抛出一个<code>unreachable</code>的错误。</li><li>其次向已经关闭的<code>channel</code>发送数据时会报”send on closed channel”的错误</li></ul><p>下面将发送过程分为三种情况</p><h4 id="3-1-写时存在阻塞的读协程——直接发送"><a href="#3-1-写时存在阻塞的读协程——直接发送" class="headerlink" title="3.1 写时存在阻塞的读协程——直接发送"></a>3.1 写时存在阻塞的读协程——直接发送</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果存在阻塞的读协程时，会直接从<code>recvq</code>中取出最先陷入等待（遵循 FIFO 原则）的<code>Goroutine</code>并直接向它发送数据，绕过缓冲区</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230825220928571.png" alt="image-20230825220928571" style="zoom:33%;" /></p><p>发送时的具体的执行逻辑由<code>send()</code>函数来完成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">        sendDirect(c.elemtype, sg, ep)</span><br><span class="line">        sg.elem = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    gp := sg.g</span><br><span class="line">    unlockf()</span><br><span class="line">    gp.param = unsafe.Pointer(sg)</span><br><span class="line">    sg.success = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">        sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>send()</code>函数主要完成了 2 件事情：</p><ol><li>调用<code>sendDirect()</code>函数将发送的数据直接拷贝到<code>x = &lt;-ch</code>表达式中变量<code>x</code>所在的内存地址上，使用的是<code>memmove()</code>函数。</li><li>调用<code>goready()</code>将等待接收的<code>g</code>的状态从<code>Gwaiting</code>或者<code>Gscanwaiting</code>变成<code>Grunnable</code>，并把该<code>g</code>放到<code>runnext</code>中，处理器在下一次调度时会立即运行它，具体逻辑可以看<code>runqput()</code>函数的代码。需要注意是，<strong>发送数据的过程并没有立即执行接收发的<code>g</code>，只是将<code>g</code>放到<code>runnext</code>中，下一次调度的时候再执行。</strong></li></ol><h4 id="3-2-channel-带有缓冲区，空间还未满并且不存在阻塞的读协程"><a href="#3-2-channel-带有缓冲区，空间还未满并且不存在阻塞的读协程" class="headerlink" title="3.2 channel 带有缓冲区，空间还未满并且不存在阻塞的读协程"></a>3.2 channel 带有缓冲区，空间还未满并且不存在阻塞的读协程</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">        qp := chanbuf(c, c.sendx)</span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            racenotify(c, c.sendx, <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">        c.sendx++</span><br><span class="line">        <span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">            c.sendx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.qcount++</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果 <code>qcount</code>还没有满，则调用<code>chanbuf()</code> 获取 <code>sendx</code> 索引的元素指针值。调用 <code>typedmemmove()</code> 方法将发送的值拷贝到缓冲区 <code>buf</code> 中。拷贝完成，需要维护 <code>sendx</code>索引下标值和<code>qcount</code> 个数。这里将 <code>buf</code> 缓冲区设计成环形的，索引值如果到了队尾，下一个位置重新回到队头。</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230826133707785.png" alt="image-20230826133707785" style="zoom:50%;" /></p><blockquote><p>图片来源：<a href="https://halfrost.com/go_channel/#toc-10">https://halfrost.com/go_channel/#toc-10</a></p></blockquote><h4 id="3-3-channel-带有缓冲区，空间已满并且不存在阻塞的读协程"><a href="#3-3-channel-带有缓冲区，空间已满并且不存在阻塞的读协程" class="headerlink" title="3.3 channel 带有缓冲区，空间已满并且不存在阻塞的读协程"></a>3.3 channel 带有缓冲区，空间已满并且不存在阻塞的读协程</h4><p>这时向<code>channel</code>发送数据会进入阻塞状态</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">gp := getg()</span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">    mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.waiting = mysg</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">c.sendq.enqueue(mysg)</span><br><span class="line">gp.parkingOnChan.Store(<span class="literal">true</span>)</span><br><span class="line">gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceBlockChanSend, <span class="number">2</span>)</span><br><span class="line">KeepAlive(ep)</span><br></pre></td></tr></table></figure><ul><li>调用<code>getg()</code>方法获取当前<code>g</code>的指针，绑定到一个<code>sudog</code>上</li><li><p>调用<code>acquireSudog()</code>方法获取一个<code>sudog</code></p></li><li><p>调用<code>c.sendq.enqueue()</code>方法将配置好的<code>sudog</code>加入队列</p></li><li>调用<code>gopark()</code>挂起当前<code>g</code>，状态为<code>waitReasonChanSend</code>，阻塞等待<code>channel</code>发送</li><li>调用<code>KeepAlive()</code>保持活动状态，等待其它协程取走元素</li></ul><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230826135153228.png" alt="image-20230826135153228" style="zoom:50%;" /></p><blockquote><p>图片来源：<a href="https://halfrost.com/go_channel/#toc-10">https://halfrost.com/go_channel/#toc-10</a></p></blockquote><h3 id="4-接收数据"><a href="#4-接收数据" class="headerlink" title="4 接收数据"></a>4 接收数据</h3><p>接收数据的实现是在<code>chanrecv()</code>函数下实现的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从一个为nil的通道中接收数据会发生异常</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceBlockForever, <span class="number">2</span>)</span><br><span class="line">    throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通道已经关闭且不存在缓存数据也会异常</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquire(c.raceaddr())</span><br><span class="line">        &#125;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemclr(c.elemtype, ep)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-读时存在阻塞的写协程"><a href="#4-1-读时存在阻塞的写协程" class="headerlink" title="4.1 读时存在阻塞的写协程"></a>4.1 读时存在阻塞的写协程</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>从阻塞的<code>sendq</code>中获取头部的<code>g</code></li><li>如果缓冲区大小为 0，则直接读取写协程元素，并唤醒它，这种情况只会发生一次<code>copy</code>操作即将阻塞的<code>g</code>所保存的元素复制到<code>read</code></li></ul><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230826151104338.png" alt="image-20230826151104338" style="zoom:50%;" /></p><ul><li>如果有缓冲区，则读取头部元素，并将处于等待发送的<code>g</code>的元素写入缓冲区的尾部（即刚刚读取的位置，因为是环形的），这种情况会发送两次<code>copy</code>操作，先将缓冲区<code>recvx</code>处的元素拷贝到<code>read</code>，然后将阻塞的<code>g</code>的元素拷贝到<code>sendx</code>所处的地址。</li></ul><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230826150504865.png" alt="image-20230826150504865" style="zoom:40%;" /></p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230826151355877.png" alt="image-20230826151355877" style="zoom:40%;" /></p><blockquote><p>图片来源：<a href="https://halfrost.com/go_channel/#toc-16">https://halfrost.com/go_channel/#toc-16</a></p></blockquote><h4 id="4-2-读取时无阻塞的写协程且缓冲区有元素"><a href="#4-2-读取时无阻塞的写协程且缓冲区有元素" class="headerlink" title="4.2 读取时无阻塞的写协程且缓冲区有元素"></a>4.2 读取时无阻塞的写协程且缓冲区有元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">        qp := chanbuf(c, c.recvx)</span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            racenotify(c, c.recvx, <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">        &#125;</span><br><span class="line">        typedmemclr(c.elemtype, qp)</span><br><span class="line">        c.recvx++</span><br><span class="line">        <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">            c.recvx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.qcount--</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>直接将<code>recvx</code>处的元素拷贝给<code>read</code>，然后将对应的属性操作，<code>qcount</code>减 1，<code>recvx</code>++，如果等于容量，则归 0，可以理解为取模操作<code>(recvx++)%qcount</code></p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230826151746532.png" alt="image-20230826151746532" style="zoom:40%;" /></p><h4 id="4-3-读时没有阻塞的写协程且缓冲区无元素"><a href="#4-3-读时没有阻塞的写协程且缓冲区无元素" class="headerlink" title="4.3 读时没有阻塞的写协程且缓冲区无元素"></a>4.3 读时没有阻塞的写协程且缓冲区无元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">gp := getg()</span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">    mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">gp.waiting = mysg</span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">c.recvq.enqueue(mysg)</span><br><span class="line">gp.parkingOnChan.Store(<span class="literal">true</span>)</span><br><span class="line">gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanReceive, traceBlockChanRecv, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><ul><li>调用<code>getg()</code>方法获取当前<code>g</code>的指针，绑定到一个<code>sudog</code>上</li><li><p>调用<code>acquireSudog()</code>方法获取一个<code>sudog</code></p></li><li><p>调用<code>c.recvq.enqueue()</code>方法将配置好的<code>sudog</code>加入队列</p></li><li>调用<code>gopark()</code>挂起当前<code>g</code>，状态为<code>waitReasonChanReceive</code>，阻塞等待<code>channel</code>接收</li></ul><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230826152412808.png" alt="image-20230826152412808" style="zoom:50%;" /></p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230826152442123.png" alt="image-20230826152442123" style="zoom:40%;" /></p><blockquote><p>图片来源<a href="https://halfrost.com/go_channel/#toc-16">https://halfrost.com/go_channel/#toc-16</a></p></blockquote><h3 id="5-关闭-Channel"><a href="#5-关闭-Channel" class="headerlink" title="5 关闭 Channel"></a>5 关闭 Channel</h3><p>关闭通道的实现在<code>closechan()</code>函数中:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;close of nil channel&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;close of closed channel&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        callerpc := getcallerpc()</span><br><span class="line">        racewritepc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(closechan))</span><br><span class="line">        racerelease(c.raceaddr())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.closed = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>当关闭<code>channel</code>是<code>nil</code>或者是一个已经关闭的<code>channel</code>时，会直接<code>panic</code>，当不存在这两种情况的时候，标记<code>channel</code>状态为<code>close</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> glist gList</span><br><span class="line"><span class="comment">// release all readers</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    sg := c.recvq.dequeue()</span><br><span class="line">    <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">        typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">        sg.elem = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">        sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    gp := sg.g</span><br><span class="line">    gp.param = unsafe.Pointer(sg)</span><br><span class="line">    sg.success = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        raceacquireg(gp, c.raceaddr())</span><br><span class="line">    &#125;</span><br><span class="line">    glist.push(gp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>recvq</code>队列中的<code>sudog</code>加入到待清除的队列<code>glist</code>中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// release all writers (they will panic)</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        sg := c.sendq.dequeue()</span><br><span class="line">        <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        sg.elem = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">            sg.releasetime = cputicks()</span><br><span class="line">        &#125;</span><br><span class="line">        gp := sg.g</span><br><span class="line">        gp.param = unsafe.Pointer(sg)</span><br><span class="line">        sg.success = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquireg(gp, c.raceaddr())</span><br><span class="line">        &#125;</span><br><span class="line">        glist.push(gp)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;c.lock)</span><br></pre></td></tr></table></figure><p>将<code>sendq</code>队列中的<code>sudog</code>加入到待清除的队列<code>glist</code>中，这里可能会产生<code>panic</code></p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230826153540944.png" alt="image-20230826153540944"></p><blockquote><p>图片来源：<a href="https://halfrost.com/go_channel/#toc-16">https://halfrost.com/go_channel/#toc-16</a></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">    gp := glist.pop()</span><br><span class="line">    gp.schedlink = <span class="number">0</span></span><br><span class="line">    goready(gp, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后会为所有被阻塞的 <code>g</code> 调用<code>goready</code> 触发调度。将所有<code>glist</code>中的<code>g</code> 状态从<code>_Gwaiting</code>设置为 <code>_Grunnable</code>状态，等待调度器的调度。</p><h3 id="6-状态总结"><a href="#6-状态总结" class="headerlink" title="6 状态总结"></a>6 状态总结</h3><div class="table-container"><table><thead><tr><th>chan state</th><th>nil</th><th>open</th><th>closed</th></tr></thead><tbody><tr><td>send</td><td>blocked</td><td>allowed</td><td>panic</td></tr><tr><td>receive</td><td>blocked</td><td>allowed</td><td>allowed</td></tr></tbody></table></div><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://speakerdeck.com/kavya719/understanding-channels?slide=32">kavya’s Understanding Channels</a></li><li><a href="https://halfrost.com/go_channel/#toc-0">https://halfrost.com/go_channel/#toc-0</a></li><li><a href="https://mp.weixin.qq.com/s/QgNndPgN1kqxWh-ijSofkw">https://mp.weixin.qq.com/s/QgNndPgN1kqxWh-ijSofkw</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>context源码学习</title>
      <link href="/2023/08/23/Context%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
      <url>/2023/08/23/Context%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>特别提醒，本文所涉及的源码是<code>go1.21.0 darwin/amd64</code></p></blockquote><h3 id="1-什么是Context"><a href="#1-什么是Context" class="headerlink" title="1. 什么是Context"></a>1. 什么是Context</h3><p>在多个goroutine之间传递上下文的对象，传递的信息包括取消信号、截止时间以及其他一些跨api边界的值</p><h3 id="2-核心数据结构"><a href="#2-核心数据结构" class="headerlink" title="2. 核心数据结构"></a>2. 核心数据结构</h3><h4 id="2-1-Context"><a href="#2-1-Context" class="headerlink" title="2.1 Context"></a>2.1 Context</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line">    Value(key any) any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Context</code>定义为<code>Interface</code>，定义了4个核心函数：</p><ul><li>Dealine：返回<code>context</code>的过期时间和一个<code>bool</code>值判断是否设置了deadline</li><li>Done：返回<code>context</code>中的<code>channel</code>，该<code>channel</code>会在当前工作完成或者上下文被取消后关闭，多次调用返回的是同一个<code>channel</code>，如果该<code>context</code>是不能被取消的，则会返回<code>nil</code></li><li>Err：返回<code>context</code>结束的原因</li><li>Value：返回<code>contxet</code>中存储的key对应的值</li></ul><h4 id="2-2-error"><a href="#2-2-error" class="headerlink" title="2.2 error"></a>2.2 error</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Canceled = errors.New(<span class="string">&quot;context canceled&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DeadlineExceeded <span class="type">error</span> = deadlineExceededError&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> deadlineExceededError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Error() <span class="type">string</span>   &#123; <span class="keyword">return</span> <span class="string">&quot;context deadline exceeded&quot;</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Timeout() <span class="type">bool</span>   &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Temporary() <span class="type">bool</span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><ul><li>Canceled：<code>context</code>被cancel时会返回该类错误</li><li>DeadlineExceeded：<code>context</code>超时时会返回该类错误</li></ul><h3 id="3-具体实现"><a href="#3-具体实现" class="headerlink" title="3 具体实现"></a>3 具体实现</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230823100804205.png" alt="image-20230823100804205" style="zoom: 33%;" /></h3><h4 id="3-1-emptyCtx"><a href="#3-1-emptyCtx" class="headerlink" title="3.1 emptyCtx"></a>3.1 emptyCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(emptyCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(emptyCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(emptyCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(emptyCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>emptyCtx</code>是一个空的<code>context</code>，之前的一些版本中是直接将它定义为一个<code>int</code>类型</p><h4 id="3-2-backgroundCtx"><a href="#3-2-backgroundCtx" class="headerlink" title="3.2 backgroundCtx"></a>3.2 backgroundCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> backgroundCtx <span class="keyword">struct</span>&#123; emptyCtx &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(backgroundCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;context.Background&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">    <span class="keyword">return</span> backgroundCtx&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Background()</code>返回一个非nil但是为空的<code>context</code>。它不能被取消，没有任何值，也没有截止时间。通常被主函数、初始化、测试以及作为传入请求的顶层<code>context</code>使用。</p><h4 id="3-3-todoCtx"><a href="#3-3-todoCtx" class="headerlink" title="3.3 todoCtx"></a>3.3 todoCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> todoCtx <span class="keyword">struct</span>&#123; emptyCtx &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(todoCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;context.TODO&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">    <span class="keyword">return</span> todoCtx&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TODO()</code>同样返回一个非nil但是为空的<code>context</code>。在代码不清楚应该使用哪个上下文或者上下文尚不可用时，应该使用<code>context.TODO</code></p><h4 id="3-4-cancelCtx"><a href="#3-4-cancelCtx" class="headerlink" title="3.4 cancelCtx"></a>3.4 cancelCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    Context</span><br><span class="line"></span><br><span class="line">    mu       sync.Mutex            <span class="comment">// protects following fields</span></span><br><span class="line">    done     atomic.Value          <span class="comment">// of chan struct&#123;&#125;, created lazily, closed by first cancel call</span></span><br><span class="line">    children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">    err      <span class="type">error</span>                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">    cause    <span class="type">error</span>                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cancelCtx</code>是取消机制的关键</p><ul><li><p>其结构体嵌入了一个`Context，作为其父类</p></li><li><p>mu：内置一把锁，用于多goroutine并发场景下的资源获取</p></li><li>done：原子类型的值，实际类型为<code>chan struct&#123;&#125;</code>，用来反应<code>cancelCtx</code>的生命周期</li><li>children：一个集合，保存了所有该<code>cancelCtx</code>的子<code>context</code></li><li><p>err：记录<code>cancelCtx</code>发生的错误</p></li><li><p>cause：记录<code>calcelCtx</code>被取消的原因</p></li></ul><h5 id="3-4-1-Value方法"><a href="#3-4-1-Value方法" class="headerlink" title="3.4.1 Value方法"></a>3.4.1 Value方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &amp;cancelCtxKey is the key that a cancelCtx returns itself for.</span></span><br><span class="line"><span class="keyword">var</span> cancelCtxKey <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">    <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">        <span class="keyword">return</span> c</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value(c.Context, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>key</code>的值为<code>&amp;cancelCtxKey</code>，则返回<code>cancelCtx</code>本身的指针，否则返回对应<code>key</code>存储的<code>value</code>值</p><h5 id="3-4-2-Done方法"><a href="#3-4-2-Done方法" class="headerlink" title="3.4.2 Done方法"></a>3.4.2 Done方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">    d := c.done.Load()</span><br><span class="line">    <span class="keyword">if</span> d != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> d.(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    d = c.done.Load()</span><br><span class="line">    <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">        d = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">        c.done.Store(d)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d.(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>前面提到<code>done</code>属性是一个原子类型的值,因此通过<code>atomic</code>包中的<code>Load()</code>函数获取它的值,如果它已经存在则直接返回</li><li>如果不存在则先加锁，然后创建一个新的<code>chan struct&#123;&#125;</code>，然后通过<code>Store()</code>赋值给<code>done</code>，可以看到这是一个懒加载机制，在第一次调用<code>c.Done()</code>的时候，该属性才被创建，返回值，然后解锁</li></ul><h5 id="3-4-3-Err方法"><a href="#3-4-3-Err方法" class="headerlink" title="3.4.3 Err方法"></a>3.4.3 Err方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    err := c.err</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加锁、读取值、解锁、返回结果</p><h5 id="3-4-4-propagateCancel方法"><a href="#3-4-4-propagateCancel方法" class="headerlink" title="3.4.4 propagateCancel方法"></a>3.4.4 propagateCancel方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> propagateCancel(parent Context, child canceler) &#123;</span><br><span class="line">    c.Context = parent</span><br><span class="line"></span><br><span class="line">    done := parent.Done()</span><br><span class="line">    <span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-done:</span><br><span class="line">        <span class="comment">// parent is already canceled</span></span><br><span class="line">        child.cancel(<span class="literal">false</span>, parent.Err(), Cause(parent))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">        <span class="comment">// parent is a *cancelCtx, or derives from one.</span></span><br><span class="line">        p.mu.Lock()</span><br><span class="line">        <span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// parent has already been canceled</span></span><br><span class="line">            child.cancel(<span class="literal">false</span>, p.err, p.cause)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">                p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> a, ok := parent.(afterFuncer); ok &#123;</span><br><span class="line">        <span class="comment">// parent implements an AfterFunc method.</span></span><br><span class="line">        c.mu.Lock()</span><br><span class="line">        stop := a.AfterFunc(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            child.cancel(<span class="literal">false</span>, parent.Err(), Cause(parent))</span><br><span class="line">        &#125;)</span><br><span class="line">        c.Context = stopCtx&#123;</span><br><span class="line">            Context: parent,</span><br><span class="line">            stop:    stop,</span><br><span class="line">        &#125;</span><br><span class="line">        c.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    goroutines.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">            child.cancel(<span class="literal">false</span>, parent.Err(), Cause(parent))</span><br><span class="line">        <span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法比较关键，会构建父子上下文之间的关联，当父上下文被取消时，子上下文也会被取消，不会出现状态不一致的情况</p><ul><li>首先将<code>parent</code>赋值给<code>Context</code>属性</li><li>如果父上下文不会取消，则直接返回</li><li>如果父上下文已经取消，则直接终止子上下文</li><li>如果父上下文是可以取消的上下文类型，即<code>cancelCtx</code>，则先加锁、然后将其加入到父上下文的<code>children</code>中，最后解锁</li><li>如果父上下文实现了<code>AfterFunc</code>方法，则在上下文被取消后，将子上下文也取消，通过调用一个<code>stop()</code>函数来实现的</li><li>如果都没满足前面的条件，则启动一个协程监控parent状态，倘若父上下文终止，则终止子上下文</li></ul><blockquote><p>进一步观察<code>parentCancelCtx</code>是如何校验<code>parent</code>是否为<code>cancelCtx</code>类型的</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> closedchan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">close</span>(closedchan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span></span> (*cancelCtx, <span class="type">bool</span>) &#123;</span><br><span class="line">    done := parent.Done()</span><br><span class="line">    <span class="keyword">if</span> done == closedchan || done == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    p, ok := parent.Value(&amp;cancelCtxKey).(*cancelCtx)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    pdone, _ := p.done.Load().(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> pdone != done &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>closedchan</code>表示一个已经关闭的通道</li><li>倘若<code>parent</code>的<code>channel</code>已经被关闭或者是不会被<code>cancel</code>的类型，则直接返回<code>false</code></li><li>倘若用<code>&amp;cancelCtxKey</code>能取到值并且得到的值是<code>parent</code>本身,返回<code>true</code>（<code>cancelCtx</code>的约定，<code>key</code>为<code>&amp;cancelCtxKey</code>的时候，返回的是<code>cancelCtx</code>本身的指针）</li></ul><h5 id="3-4-5-String方法"><a href="#3-4-5-String方法" class="headerlink" title="3.4.5 String方法"></a>3.4.5 String方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> contextName(c.Context) + <span class="string">&quot;.WithCancel&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回<code>cancelCtx</code>的名字</p><h5 id="3-4-6-cancel方法"><a href="#3-4-6-cancel方法" class="headerlink" title="3.4.6 cancel方法"></a>3.4.6 cancel方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err, cause <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;context: internal error: missing cancel error&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> cause == <span class="literal">nil</span> &#123;</span><br><span class="line">        cause = err</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// already canceled</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.err = err</span><br><span class="line">    c.cause = cause</span><br><span class="line">    d, _ := c.done.Load().(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">        c.done.Store(closedchan)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">close</span>(d)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> acquiring the child&#x27;s lock while holding parent&#x27;s lock.</span></span><br><span class="line">        child.cancel(<span class="literal">false</span>, err, cause)</span><br><span class="line">    &#125;</span><br><span class="line">    c.children = <span class="literal">nil</span></span><br><span class="line">    c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">        removeChild(c.Context, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>该方法接收三个参数，<code>removeFromParent</code>是一个<code>bool</code>值，表示需要从当前<code>context</code>的父<code>context</code>的<code>children</code>中删除</li><li>加锁，判断自己的<code>err</code>是否为空，如果不为空，说明已经被<code>cancel</code>，直接返回</li><li>处理 <code>cancelCtx</code> 的 <code>channel</code>，若<code>channel</code> 此前未初始化，则直接注入一个 <code>closedChan</code>，否则关闭该 <code>channel</code></li><li>遍历该<code>cancelCtx</code>的子<code>context</code>，依次将其<code>cancel</code></li><li>解锁，最后根据传入的参数<code>removeFromParent</code>，判断是否需要手动把 <code>cancelCtx</code> 从 <code>parent</code> 的<code>children</code> 集合中移除</li></ul><blockquote><p>走进 <code>removeChild</code> 方法中，观察如何将 <code>cancelCtx</code> 从<code>parent</code> 的<code>children</code> 集合 中移除：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeChild</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s, ok := parent.(stopCtx); ok &#123;</span><br><span class="line">        s.stop()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    p, ok := parentCancelCtx(parent)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    p.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> p.children != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">delete</span>(p.children, child)</span><br><span class="line">    &#125;</span><br><span class="line">    p.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果<code>parent</code>不是<code>cancelCtx</code>类型的，则直接返回（因为只有 <code>cancelCtx</code> 才有 <code>children</code>集合）</li><li>加锁，将集合中<code>key</code>为<code>child</code>的删除，解锁</li></ul><h4 id="3-5-timerCtx"><a href="#3-5-timerCtx" class="headerlink" title="3.5 timerCtx"></a>3.5 timerCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    cancelCtx</span><br><span class="line">    timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line"></span><br><span class="line">    deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>timerCtx</code>在<code>cancelCtx</code>的基础上，又做了一层封装，新增了一个<code>time.Timer</code>用于定时终止<code>context</code>，另外新增一个<code>deadline</code>用于记录过期时间</p><h5 id="3-5-1-Deadline方法"><a href="#3-5-1-Deadline方法" class="headerlink" title="3.5.1 Deadline方法"></a>3.5.1 Deadline方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> c.deadline, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回过期时间</p><h5 id="3-5-2-String方法"><a href="#3-5-2-String方法" class="headerlink" title="3.5.2 String方法"></a>3.5.2 String方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> contextName(c.cancelCtx.Context) + <span class="string">&quot;.WithDeadline(&quot;</span> +</span><br><span class="line">        c.deadline.String() + <span class="string">&quot; [&quot;</span> +</span><br><span class="line">        time.Until(c.deadline).String() + <span class="string">&quot;])&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回<code>context</code>的名字加上过期时间</p><h5 id="3-5-3-cancel方法"><a href="#3-5-3-cancel方法" class="headerlink" title="3.5.3 cancel方法"></a>3.5.3 cancel方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err, cause <span class="type">error</span>) &#123;</span><br><span class="line">    c.cancelCtx.cancel(<span class="literal">false</span>, err, cause)</span><br><span class="line">    <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">        <span class="comment">// Remove this timerCtx from its parent cancelCtx&#x27;s children.</span></span><br><span class="line">        removeChild(c.cancelCtx.Context, c)</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.timer.Stop()</span><br><span class="line">        c.timer = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>继承<code>cancelCtx</code>的<code>cancel</code>方法，进行处理</li><li>判断是否需要从 <code>parent</code> 的 <code>children</code> 集合 中移除，若是则进行处理</li><li>加锁、停止<code>time.Timer</code>、解锁返回</li></ul><h4 id="3-6-valueCtx"><a href="#3-6-valueCtx" class="headerlink" title="3.6 valueCtx"></a>3.6 valueCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    Context</span><br><span class="line">    key, val any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>valueCtx</code>同样继承了<code>Context</code>，同时一个<code>valueCtx</code>只能存储一对<code>kv</code></p><h5 id="3-6-1-String方法"><a href="#3-6-1-String方法" class="headerlink" title="3.6.1 String方法"></a>3.6.1 String方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> contextName(c.Context) + <span class="string">&quot;.WithValue(type &quot;</span> +</span><br><span class="line">        reflectlite.TypeOf(c.key).String() +</span><br><span class="line">        <span class="string">&quot;, val &quot;</span> + stringify(c.val) + <span class="string">&quot;)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回<code>valueCtx</code>的名字以及存储的<code>kv</code>值</p><h5 id="3-6-2-Value方法"><a href="#3-6-2-Value方法" class="headerlink" title="3.6.2 Value方法"></a>3.6.2 Value方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">    <span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">        <span class="keyword">return</span> c.val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value(c.Context, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果参数的<code>key</code>等于他所保存的<code>key</code>则返回所保存的<code>value</code></li><li>否则去<code>parent</code>的<code>Context</code>去找</li></ul><p>进一步观察是如何在<code>parent</code>中寻找的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">value</span><span class="params">(c Context, key any)</span></span> any &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> ctx := c.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> *valueCtx:</span><br><span class="line">            <span class="keyword">if</span> key == ctx.key &#123;</span><br><span class="line">                <span class="keyword">return</span> ctx.val</span><br><span class="line">            &#125;</span><br><span class="line">            c = ctx.Context</span><br><span class="line">        <span class="keyword">case</span> *cancelCtx:</span><br><span class="line">            <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">                <span class="keyword">return</span> c</span><br><span class="line">            &#125;</span><br><span class="line">            c = ctx.Context</span><br><span class="line">        <span class="keyword">case</span> withoutCancelCtx:</span><br><span class="line">            <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">                <span class="comment">// This implements Cause(ctx) == nil</span></span><br><span class="line">                <span class="comment">// when ctx is created using WithoutCancel.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            c = ctx.c</span><br><span class="line">        <span class="keyword">case</span> *timerCtx:</span><br><span class="line">            <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">                <span class="keyword">return</span> &amp;ctx.cancelCtx</span><br><span class="line">            &#125;</span><br><span class="line">            c = ctx.Context</span><br><span class="line">        <span class="keyword">case</span> backgroundCtx, todoCtx:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> c.Value(key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动一个 for 循环，一直往上去父上下文中寻找</li><li>其中不同的上下文类型会有不同的处理方式；</li><li>找到匹配的 key，则将该value 进行返回.</li></ul><h3 id="4-创建context"><a href="#4-创建context" class="headerlink" title="4 创建context"></a>4 创建context</h3><h4 id="4-1-cancelCtx"><a href="#4-1-cancelCtx" class="headerlink" title="4.1 cancelCtx"></a>4.1 cancelCtx</h4><p>有两种方法，一个不带<code>cause</code>，一个带有<code>cause</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line">    c := withCancel(parent)</span><br><span class="line">    <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled, <span class="literal">nil</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancelCause</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelCauseFunc) &#123;</span><br><span class="line">    c := withCancel(parent)</span><br><span class="line">    <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">(cause <span class="type">error</span>)</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled, cause) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-withoutCancelCtx"><a href="#4-2-withoutCancelCtx" class="headerlink" title="4.2 withoutCancelCtx"></a>4.2 withoutCancelCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithoutCancel</span><span class="params">(parent Context)</span></span> Context &#123;</span><br><span class="line">    <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> withoutCancelCtx&#123;parent&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-Deadline"><a href="#4-3-Deadline" class="headerlink" title="4.3 Deadline"></a>4.3 Deadline</h4><p>同样有两种方法，一个不带<code>cause</code>，一个带有<code>cause</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line">    <span class="keyword">return</span> WithDeadlineCause(parent, d, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadlineCause</span><span class="params">(parent Context, d time.Time, cause <span class="type">error</span>)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line">    <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line">        <span class="comment">// The current deadline is already sooner than the new one.</span></span><br><span class="line">        <span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">    &#125;</span><br><span class="line">    c := &amp;timerCtx&#123;</span><br><span class="line">        deadline: d,</span><br><span class="line">    &#125;</span><br><span class="line">    c.cancelCtx.propagateCancel(parent, c)</span><br><span class="line">    dur := time.Until(d)</span><br><span class="line">    <span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        c.cancel(<span class="literal">true</span>, DeadlineExceeded, cause) <span class="comment">// deadline has already passed</span></span><br><span class="line">        <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">false</span>, Canceled, <span class="literal">nil</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    <span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">        c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            c.cancel(<span class="literal">true</span>, DeadlineExceeded, cause)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled, <span class="literal">nil</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-Timeout"><a href="#4-4-Timeout" class="headerlink" title="4.4 Timeout"></a>4.4 Timeout</h4><p>同样有两种方法，一个不带<code>cause</code>，一个带有<code>cause</code>，最后都是通过<code>WithDeadlineCause</code>来创建的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line">    <span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeoutCause</span><span class="params">(parent Context, timeout time.Duration, cause <span class="type">error</span>)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line">    <span class="keyword">return</span> WithDeadlineCause(parent, time.Now().Add(timeout), cause)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-ValueCtx"><a href="#4-5-ValueCtx" class="headerlink" title="4.5 ValueCtx"></a>4.5 ValueCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val any)</span></span> Context &#123;</span><br><span class="line">    <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;nil key&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;key is not comparable&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
