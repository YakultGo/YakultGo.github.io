<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>slice源码学习</title>
      <link href="/2023/09/01/slice%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/09/01/slice%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">s = <span class="built_in">append</span>(s[:<span class="number">2</span>], s[<span class="number">3</span>:]...)</span><br><span class="line">t.Logf(<span class="string">&quot;s: %v, len: %d, cap: %d&quot;</span>, s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">v := s[<span class="number">4</span>]</span><br><span class="line"><span class="comment">// 是否会数组访问越界</span></span><br><span class="line">t.Log(v)</span><br></pre></td></tr></table></figure><blockquote><p>特别提醒，本文所涉及的源码是<code>go1.21.0 darwin/amd64</code><br>文件位置：runtime&#x2F;slice.go</p></blockquote><h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1 数据结构"></a>1 数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>array：指向存储元素内存空间的起始地点</li><li>len：切片的长度</li><li>cap：切片的容量</li></ul><h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2 初始化"></a>2 初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice</span><span class="params">(et *_type, <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// 判断分配的内存是否会溢出</span></span><br><span class="line">    mem, overflow := math.MulUintptr(et.Size_, <span class="type">uintptr</span>(<span class="built_in">cap</span>))</span><br><span class="line">    <span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> || <span class="built_in">len</span> &gt; <span class="built_in">cap</span> &#123;</span><br><span class="line">        mem, overflow := math.MulUintptr(et.Size_, <span class="type">uintptr</span>(<span class="built_in">len</span>))</span><br><span class="line">        <span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> &#123;</span><br><span class="line">            panicmakeslicelen()</span><br><span class="line">        &#125;</span><br><span class="line">        panicmakeslicecap()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="keyword">return</span> mallocgc(mem, et, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-扩容"><a href="#3-扩容" class="headerlink" title="3 扩容"></a>3 扩容</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(oldPtr unsafe.Pointer, newLen, oldCap, num <span class="type">int</span>, et *_type)</span></span> slice &#123;</span><br><span class="line">    <span class="comment">// 旧切片的长度</span></span><br><span class="line">    oldLen := newLen - num</span><br><span class="line">    <span class="keyword">if</span> newLen &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(errorString(<span class="string">&quot;growslice: len out of range&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 元素大小为0，则直接分配</span></span><br><span class="line">    <span class="keyword">if</span> et.Size_ == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// append should not create a slice with nil pointer but non-zero len.</span></span><br><span class="line">        <span class="comment">// We assume that append doesn&#x27;t need to preserve oldPtr in this case.</span></span><br><span class="line">        <span class="keyword">return</span> slice&#123;unsafe.Pointer(&amp;zerobase), newLen, newLen&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断新切片的容量大小</span></span><br><span class="line">    newcap := oldCap</span><br><span class="line">    doublecap := newcap + newcap</span><br><span class="line">    <span class="comment">// 如果新切片的长度大于旧切片容量的两倍，则将新切片的长度赋值给容量</span></span><br><span class="line">    <span class="keyword">if</span> newLen &gt; doublecap &#123;</span><br><span class="line">        newcap = newLen</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> threshold = <span class="number">256</span></span><br><span class="line">        <span class="comment">// 旧切片的容量小于256</span></span><br><span class="line">        <span class="keyword">if</span> oldCap &lt; threshold &#123;</span><br><span class="line">            <span class="comment">// 两倍扩容</span></span><br><span class="line">            newcap = doublecap</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 一直增加，直到大于切片的长度</span></span><br><span class="line">            <span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; newLen &#123;</span><br><span class="line">                <span class="comment">// 扩容速度为1/4的原来容量+固定值192</span></span><br><span class="line">                newcap += (newcap + <span class="number">3</span>*threshold) / <span class="number">4</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 超过int32类型大小，则将长度赋值给容量</span></span><br><span class="line">            <span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">                newcap = newLen</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> overflow <span class="type">bool</span></span><br><span class="line">    <span class="keyword">var</span> lenmem, newlenmem, capmem <span class="type">uintptr</span></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> et.Size_ == <span class="number">1</span>:<span class="comment">// 元素大小为1</span></span><br><span class="line">        lenmem = <span class="type">uintptr</span>(oldLen)</span><br><span class="line">        newlenmem = <span class="type">uintptr</span>(newLen)</span><br><span class="line">        capmem = roundupsize(<span class="type">uintptr</span>(newcap))</span><br><span class="line">        overflow = <span class="type">uintptr</span>(newcap) &gt; maxAlloc</span><br><span class="line">        newcap = <span class="type">int</span>(capmem)</span><br><span class="line">    <span class="keyword">case</span> et.Size_ == goarch.PtrSize:<span class="comment">// 元素是指针类型</span></span><br><span class="line">        lenmem = <span class="type">uintptr</span>(oldLen) * goarch.PtrSize</span><br><span class="line">        newlenmem = <span class="type">uintptr</span>(newLen) * goarch.PtrSize</span><br><span class="line">        capmem = roundupsize(<span class="type">uintptr</span>(newcap) * goarch.PtrSize)</span><br><span class="line">        overflow = <span class="type">uintptr</span>(newcap) &gt; maxAlloc/goarch.PtrSize</span><br><span class="line">        newcap = <span class="type">int</span>(capmem / goarch.PtrSize)</span><br><span class="line">    <span class="keyword">case</span> isPowerOfTwo(et.Size_):<span class="comment">// 元素大小是2的幂</span></span><br><span class="line">        <span class="keyword">var</span> shift <span class="type">uintptr</span></span><br><span class="line">        <span class="keyword">if</span> goarch.PtrSize == <span class="number">8</span> &#123;</span><br><span class="line">            shift = <span class="type">uintptr</span>(sys.TrailingZeros64(<span class="type">uint64</span>(et.Size_))) &amp; <span class="number">63</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            shift = <span class="type">uintptr</span>(sys.TrailingZeros32(<span class="type">uint32</span>(et.Size_))) &amp; <span class="number">31</span></span><br><span class="line">        &#125;<span class="comment">// 通过移位操作，性能更高效</span></span><br><span class="line">        lenmem = <span class="type">uintptr</span>(oldLen) &lt;&lt; shift</span><br><span class="line">        newlenmem = <span class="type">uintptr</span>(newLen) &lt;&lt; shift</span><br><span class="line">        capmem = roundupsize(<span class="type">uintptr</span>(newcap) &lt;&lt; shift)</span><br><span class="line">        overflow = <span class="type">uintptr</span>(newcap) &gt; (maxAlloc &gt;&gt; shift)</span><br><span class="line">        newcap = <span class="type">int</span>(capmem &gt;&gt; shift)</span><br><span class="line">        capmem = <span class="type">uintptr</span>(newcap) &lt;&lt; shift</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        lenmem = <span class="type">uintptr</span>(oldLen) * et.Size_</span><br><span class="line">        newlenmem = <span class="type">uintptr</span>(newLen) * et.Size_</span><br><span class="line">        capmem, overflow = math.MulUintptr(et.Size_, <span class="type">uintptr</span>(newcap))</span><br><span class="line">        capmem = roundupsize(capmem)</span><br><span class="line">        newcap = <span class="type">int</span>(capmem / et.Size_)</span><br><span class="line">        capmem = <span class="type">uintptr</span>(newcap) * et.Size_</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> overflow || capmem &gt; maxAlloc &#123;</span><br><span class="line">        <span class="built_in">panic</span>(errorString(<span class="string">&quot;growslice: len out of range&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新的内存地址</span></span><br><span class="line">    <span class="keyword">var</span> p unsafe.Pointer</span><br><span class="line">    <span class="keyword">if</span> et.PtrBytes == <span class="number">0</span> &#123;<span class="comment">// 无指针</span></span><br><span class="line">        p = mallocgc(capmem, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">        memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 有指针</span></span><br><span class="line">        p = mallocgc(capmem, et, <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">if</span> lenmem &gt; <span class="number">0</span> &amp;&amp; writeBarrier.enabled &#123;</span><br><span class="line">            bulkBarrierPreWriteSrcOnly(<span class="type">uintptr</span>(p), <span class="type">uintptr</span>(oldPtr), lenmem-et.Size_+et.PtrBytes)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memmove(p, oldPtr, lenmem)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slice&#123;p, newLen, newcap&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容规则：</p><ol><li>如果新切片的长度大于旧切片容量的两倍，则直接将新切片的长度作为容量</li><li>容量小于256，直接两倍扩容</li><li>大于256，则循环扩容加上1&#x2F;4容量和一个固定值192，</li></ol><h3 id="4-切片拷贝"><a href="#4-切片拷贝" class="headerlink" title="4 切片拷贝"></a>4 切片拷贝</h3><h4 id="4-1-赋值拷贝"><a href="#4-1-赋值拷贝" class="headerlink" title="4.1 赋值拷贝"></a>4.1 赋值拷贝</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">s2 := s1[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure><p>这种通过赋值来拷贝的，两者会共用一个底层数组，意思就是两者指向的元素是相同的，即</p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230901214335034.png" alt="image-20230901214335034" style="zoom:40%;" /><h4 id="4-2-copy或者slicecopy"><a href="#4-2-copy或者slicecopy" class="headerlink" title="4.2 copy或者slicecopy"></a>4.2 copy或者slicecopy</h4><p>如果不想要两个指向的同一个数组，则通过<code>copy</code>或者<code>slicecopy</code>来进行拷贝，两种拷贝方式都会通过 <code>runtime.memmove</code>将整块内存的内容拷贝到目标的内存区域中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicecopy</span><span class="params">(toPtr unsafe.Pointer, toLen <span class="type">int</span>, fromPtr unsafe.Pointer, fromLen <span class="type">int</span>, width <span class="type">uintptr</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fromLen == <span class="number">0</span> || toLen == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    n := fromLen</span><br><span class="line">    <span class="keyword">if</span> toLen &lt; n &#123;</span><br><span class="line">        n = toLen</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> width == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">1</span> &#123; <span class="comment">// common case worth about 2x to do here</span></span><br><span class="line">        *(*<span class="type">byte</span>)(toPtr) = *(*<span class="type">byte</span>)(fromPtr) <span class="comment">// known to be a byte pointer</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        memmove(toPtr, fromPtr, size)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230901214757321.png" alt="image-20230901214757321" style="zoom:40%;" /><h3 id="5-追加和删除"><a href="#5-追加和删除" class="headerlink" title="5 追加和删除"></a>5 追加和删除</h3><p>追加操作比较简单通过<code>append()</code>即可实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;  </span><br><span class="line">s = <span class="built_in">append</span>(s,<span class="number">5</span>)<span class="comment">// [2,3,4,5]</span></span><br></pre></td></tr></table></figure><p>删除操作有如下几种情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">s = s[<span class="number">1</span>:]<span class="comment">// [1,2,3,4]</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">append</span>(s[:<span class="number">2</span>],s[<span class="number">3</span>:]...)<span class="comment">// [0,1,3,4]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码解读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map源码学习</title>
      <link href="/2023/09/01/map%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/09/01/map%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>特别提醒，本文所涉及的源码是<code>go1.21.0 darwin/amd64</code></p><p>文件位置：runtime&#x2F;map.go</p></blockquote><blockquote><p>哈希表作为一种非常常见的数据结构，在其它语言中也都会有出现，因此本文不对哈希表的概念、用法做解释，专注于go语言中的源码学习。</p></blockquote><h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1 数据结构"></a>1 数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count     <span class="type">int</span> <span class="comment">// 当前map中的元素数量</span></span><br><span class="line">    flags     <span class="type">uint8</span></span><br><span class="line">    B         <span class="type">uint8</span> </span><br><span class="line">    noverflow <span class="type">uint16</span> </span><br><span class="line">    hash0     <span class="type">uint32</span> <span class="comment">// 哈希种子，在创建map时得到的一个随机数</span></span><br><span class="line">    buckets    unsafe.Pointer <span class="comment">// 桶数组</span></span><br><span class="line">    oldbuckets unsafe.Pointer <span class="comment">// 扩容过程中旧的桶数组</span></span><br><span class="line">    nevacuate  <span class="type">uintptr</span>        </span><br><span class="line">    extra *mapextra <span class="comment">// 额外记录的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>flags：标志位</p><ul><li>iterator &#x3D; 1：可能有迭代器在遍历<code>buckets</code></li><li>oldIterator  &#x3D; 2：可能有迭代器在遍历<code>oldbuckets</code>，用于扩容期间</li><li>hashWriting  &#x3D; 4：标记一个<code>g</code>正在写<code>map</code></li><li>sameSizeGrow &#x3D; 8：等量扩容</li></ul></li><li><p>B：桶数量的指数，即<code>len(buckets)</code>$&#x3D;2^B$</p></li><li><p>noverflow：溢出同的数量，当其接近$2^{15}-1$时为近似值</p></li><li><p>nevacuate：扩容过程中的进度标识（index小于它的桶已经被转移到新桶中了）</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">    overflow    *[]*bmap</span><br><span class="line">    oldoverflow *[]*bmap</span><br><span class="line">    nextOverflow *bmap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>map</code>中的<code>kev</code>和<code>value</code>不包含指针时，<code>overflow</code>和<code>oldoverflow</code>才被使用</p><ul><li>overflow：<code>hmap.buckets</code> 使用的溢出桶</li><li>oldoverflow：<code>hmap.oldbuckets</code>使用的溢出桶</li><li>nextOverflow：下一个可以用的溢出桶</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// bucketCnt=8</span></span><br><span class="line">    tophash [bucketCnt]<span class="type">uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>tophash： $\leq5$时存放的是状态。$\gt5$时存放的是高8位的<code>hash</code>值，用于快速判断<code>key</code>是否存在<ul><li>emptyRest &#x3D; 0： 此单元为空，且更高索引的单元也为空</li><li>emptyOne &#x3D; 1： 此单元为空</li><li>evacuatedX &#x3D; 2： 用于表示扩容迁移到新桶前半段区间，即索引没变</li><li>evacuatedY &#x3D; 3： 用于表示扩容迁移到新桶后半段区间，即在新桶中的索引&#x3D;旧桶索引+扩容前容量大小</li><li>evacuatedEmpty &#x3D; 4： 用于表示此桶已迁移完成</li><li>minTopHash &#x3D; 5： 最小的空桶标记值，小于其则是空桶标志</li></ul></li></ul><p>在<code>runtime/map.go</code>文件中<code>bmap</code>只包含了一个简单的<code>tophash</code>字段，但是在运行期间会根据<code>key</code>和<code>value</code>的类型对<code>bmap</code>的结构进行重建如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    topbits  [<span class="number">8</span>]<span class="type">uint8</span></span><br><span class="line">    keys     [<span class="number">8</span>]keytype</span><br><span class="line">    elems    [<span class="number">8</span>]elemype</span><br><span class="line">    overflow <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>相关代码在：cmd&#x2F;compile&#x2F;internal&#x2F;reflectdata&#x2F;reflect.go:   MapBucketType</p></blockquote><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230831164229965.png" alt="image-20230831164229965"></p><h3 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2 构造方法"></a>2 构造方法</h3><p>创建<code>map</code>时，实际上会调用<code>makemap()</code>方法，该方法分析如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="type">int</span>, h *hmap)</span></span> *hmap</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mem, overflow := math.MulUintptr(<span class="type">uintptr</span>(hint), t.Bucket.Size_)</span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc &#123;</span><br><span class="line">    hint = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hint</code>是为<code>map</code>拟分配的容量，再分配前会对拟分配的内存大小进行判断，如果超过限制大小，则会将<code>hint</code>设置为零</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">    h = <span class="built_in">new</span>(hmap)</span><br><span class="line">&#125;</span><br><span class="line">h.hash0 = fastrand()</span><br></pre></td></tr></table></figure><p>初始化<code>h</code>，并设置哈希种子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">B := <span class="type">uint8</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> overLoadFactor(hint, B) &#123;</span><br><span class="line">    B++</span><br><span class="line">&#125;</span><br><span class="line">h.B = B</span><br></pre></td></tr></table></figure><p>首先初始化<code>B</code>为0，然后根据$\frac{hint}{6}&gt;2^B$如果成立则B+1，最后直到B不成立为止，即让$\frac{hint}{2^B}$负载因子小于等于6</p><p>map 预分配容量、桶数组长度指数、桶数组长度之间的关系如下表：</p><table><thead><tr><th>kv对数量</th><th>指数B</th><th>长度$2^B$</th></tr></thead><tbody><tr><td>0~8</td><td>0</td><td>1</td></tr><tr><td>9~12</td><td>1</td><td>2</td></tr><tr><td>13~24</td><td>2</td><td>4</td></tr><tr><td>25~48</td><td>3</td><td>8</td></tr><tr><td>$2^{B-1}<em>6+1$~$ 2^B</em>6$</td><td>B</td><td>$2^B$</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> h.B != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nextOverflow *bmap</span><br><span class="line">    h.buckets, nextOverflow = makeBucketArray(t, h.B, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">        h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">        h.extra.nextOverflow = nextOverflow</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>makeBucketArray</code>初始化桶数组<code>buckets</code>，如果<code>map</code>容量过大，会提前申请溢出桶</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeBucketArray</span><span class="params">(t *maptype, b <span class="type">uint8</span>, dirtyalloc unsafe.Pointer)</span></span> (buckets unsafe.Pointer, nextOverflow *bmap) &#123;</span><br><span class="line">    base := bucketShift(b)</span><br><span class="line">    nbuckets := base</span><br><span class="line">    <span class="keyword">if</span> b &gt;= <span class="number">4</span> &#123;</span><br><span class="line">        nbuckets += bucketShift(b - <span class="number">4</span>)</span><br><span class="line">        sz := t.Bucket.Size_ * nbuckets</span><br><span class="line">        up := roundupsize(sz)</span><br><span class="line">        <span class="keyword">if</span> up != sz &#123;</span><br><span class="line">            nbuckets = up / t.Bucket.Size_</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> dirtyalloc == <span class="literal">nil</span> &#123;</span><br><span class="line">        buckets = newarray(t.Bucket, <span class="type">int</span>(nbuckets))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buckets = dirtyalloc</span><br><span class="line">        size := t.Bucket.Size_ * nbuckets</span><br><span class="line">        <span class="keyword">if</span> t.Bucket.PtrBytes != <span class="number">0</span> &#123;</span><br><span class="line">            memclrHasPointers(buckets, size)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            memclrNoHeapPointers(buckets, size)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> base != nbuckets &#123;</span><br><span class="line">        nextOverflow = (*bmap)(add(buckets, base*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">        last := (*bmap)(add(buckets, (nbuckets<span class="number">-1</span>)*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">        last.setoverflow(t, (*bmap)(buckets))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buckets, nextOverflow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>B</code>大于4的话，会额外多创建$2^{B-4}$个溢出桶（内存对齐），并将<code>h.nextOverflow</code>指向第一个溢出桶的地址，最后一个溢出桶的地址设置为<code>h.buckets</code>(方便判断溢出桶已经用完)</p><h3 id="3-读操作"><a href="#3-读操作" class="headerlink" title="3 读操作"></a>3 读操作</h3><p><code>map</code>的读操作一般是通过下标或者遍历进行的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">value = hash[key]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> hash &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种方式都能够读取，但是所使用到的函数和底层的原理是不同的</p><h4 id="3-1-通过key来读取"><a href="#3-1-通过key来读取" class="headerlink" title="3.1 通过key来读取"></a>3.1 通过key来读取</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value := hash[key]<span class="comment">// =&gt; v     := mapaccess1(maptype, hash, &amp;key)</span></span><br><span class="line">value,ok := hash[key]<span class="comment">// =&gt; v, ok := mapaccess2(maptype, hash, &amp;key)</span></span><br></pre></td></tr></table></figure><ul><li>当只需要一个返回值时，会调用<code>mapaccess1()</code>函数</li><li>当需要两个返回值时，会调用<code>mapaccess2()</code>函数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t.HashMightPanic() &#123;</span><br><span class="line">        t.Hasher(key, <span class="number">0</span>) <span class="comment">// see issue 23734</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1 如果<code>h</code>未初始化或者<code>map</code>中的<code>k-v</code>对为0，则会直接返回一个零值对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">    fatal(<span class="string">&quot;concurrent map read and map write&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 如果此时有其它的<code>g</code>在对<code>map</code>进行写操作，则直接返回<code>fatal</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hash := t.Hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">m := bucketMask(h.B)</span><br><span class="line">b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="type">uintptr</span>(t.BucketSize)))</span><br></pre></td></tr></table></figure><p>3 通过<code>MapType.Hasher()</code>方法得到<code>key</code>对应的<code>hash</code>值并对桶数量取模，获取对应桶的索引</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">        <span class="comment">// There used to be half as many buckets; mask down one more power of two.</span></span><br><span class="line">        m &gt;&gt;= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    oldb := (*bmap)(add(c, (hash&amp;m)*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">    <span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">        b = oldb</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4 判断<code>map</code>是否正在扩容，首先判断是否进行增量扩容，倘若是的话，需要将m除以2，因为旧桶的长度只是新桶的一半，然后通过<code>evacuated</code>判断要找的桶是否在旧的桶数组里面，如果是则需要去旧的桶数组当中去找。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">top := tophash(hash)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tophash</span><span class="params">(hash <span class="type">uintptr</span>)</span></span> <span class="type">uint8</span> &#123;</span><br><span class="line">    top := <span class="type">uint8</span>(hash &gt;&gt; (goarch.PtrSize*<span class="number">8</span> - <span class="number">8</span>))</span><br><span class="line">    <span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">        top += minTopHash</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5 获取<code>hash</code>值的高八位，如果该值小于5，会加上5，以避开0~4这个区间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">bucketloop:</span><br><span class="line">    <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">                <span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">                    <span class="keyword">break</span> bucketloop</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">            <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                k = *((*unsafe.Pointer)(k))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> t.Key.Equal(key, k) &#123;</span><br><span class="line">                e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.KeySize)+i*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">                <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">                    e = *((*unsafe.Pointer)(e))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> e</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>6 外层<code>for</code>循环会遍历要查找的那个桶及其后续的溢出桶，里层<code>for</code>循环遍历桶内的<code>key-value</code>对。遍历时首先查询高8位的<code>tophash</code>值，如果和<code>key</code>的对应不上，并且当前位置的<code>tophash</code>为0，则后面没有元素，直接结束这个桶的遍历。倘若找到了相等的<code> key</code>，则通过地址偏移的方式取到 <code>value</code> 并返回，如果遍历了所有桶都没找到，则返回一个零值。</p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230829203844637.png" alt="image-20230829203844637" style="zoom:40%;" /><h3 id="4-写操作"><a href="#4-写操作" class="headerlink" title="4 写操作"></a>4 写操作</h3><p>写操作的实现由<code>mapassign</code>函数实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回待更新的value地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    hash := t.hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">    <span class="comment">// 桶为空，则分配一个桶</span></span><br><span class="line">    <span class="keyword">if</span> h.buckets == <span class="literal">nil</span> &#123;</span><br><span class="line">        h.buckets = newobject(t.bucket) <span class="comment">// newarray(t.bucket, 1)</span></span><br><span class="line">    &#125;</span><br><span class="line">again:</span><br><span class="line">    bucket := hash &amp; bucketMask(h.B)<span class="comment">//获取目标桶序号</span></span><br><span class="line">    <span class="comment">// 如果还处于扩容中，我们要让这个key对应的旧桶立马迁移到新桶</span></span><br><span class="line">    <span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">        growWork(t, h, bucket)<span class="comment">//见扩容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// b就是目标桶</span></span><br><span class="line">    b := (*bmap)(add(h.buckets, bucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">  top := tophash(hash)<span class="comment">//hash高8位</span></span><br><span class="line">    <span class="keyword">var</span> inserti *<span class="type">uint8</span><span class="comment">//tophash</span></span><br><span class="line">    <span class="keyword">var</span> insertk unsafe.Pointer<span class="comment">//key</span></span><br><span class="line">    <span class="keyword">var</span> elem unsafe.Pointer<span class="comment">//value</span></span><br><span class="line">bucketloop:</span><br><span class="line">    <span class="comment">// 外循环是遍历桶，内循环是遍历每个桶的8个kv对</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">                <span class="comment">// 找到了第一个空的存放地址</span></span><br><span class="line">                <span class="keyword">if</span> isEmpty(b.tophash[i]) &amp;&amp; inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">                    inserti = &amp;b.tophash[i]</span><br><span class="line">                    insertk = add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">                    elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果后续的所有cell都是空的了，没必要再查询</span></span><br><span class="line">                <span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">                    <span class="keyword">break</span> bucketloop</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">            <span class="comment">// tophash相同后，再比较key进行确认</span></span><br><span class="line">            <span class="keyword">if</span> !t.key.equal(key, k) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//并将待更新的value地址返回</span></span><br><span class="line">            elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">            <span class="keyword">goto</span> done</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取下一个溢出桶</span></span><br><span class="line">        ovf := b.overflow(t)</span><br><span class="line">        <span class="keyword">if</span> ovf == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        b = ovf</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面就是map没有存key的情况</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当不处于扩容时，超过负载因子或者太多溢出桶，即溢出桶个数大于等于1&lt;&lt; min(h.B,15)</span></span><br><span class="line">    <span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">        hashGrow(t, h)<span class="comment">// 分配新桶，但还不迁移旧桶，见扩容部分</span></span><br><span class="line">        <span class="keyword">goto</span> again </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没找到任何空位</span></span><br><span class="line">    <span class="keyword">if</span> inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 从溢出桶池拿或者分配溢出桶内存，见下文</span></span><br><span class="line">        newb := h.newoverflow(t, b)</span><br><span class="line">        inserti = &amp;newb.tophash[<span class="number">0</span>]</span><br><span class="line">        insertk = add(unsafe.Pointer(newb), dataOffset)</span><br><span class="line">        elem = add(insertk, bucketCnt*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">    &#125;</span><br><span class="line">    *inserti = top<span class="comment">// 设置tophash</span></span><br><span class="line">    h.count++<span class="comment">// map元素数量+1</span></span><br><span class="line">done:</span><br><span class="line">    <span class="keyword">return</span> elem<span class="comment">//将存取value的地址返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230831170342743.png" alt="image-20230831170342743" style="zoom:40%;" /><h3 id="5-删除操作"><a href="#5-删除操作" class="headerlink" title="5 删除操作"></a>5 删除操作</h3><p><code>map</code>相关的删除操作在<code>mapdelete()</code>函数下面，与更新操作类似，多了一个修改当前<code>tophash</code>状态的步骤</p><p>首先会将当前的<code>tophash[i]</code>更新为<code>emptyOne</code>，这个不仅仅是操作自己的<code>tophash[i]</code>还要判断它的下一个是不是<code>emptyRest</code>，如果下一个为<code>emptyRest</code>，那么就可以将<code>tophash[i]</code>进一步更新为<code>emptyRest</code>，并且还需要判断之前的<code>tophash</code>如果之前的为<code>emptyOne</code>则要修改为<code>emptyRest</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapdelete</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> &#123;</span><br><span class="line">  <span class="comment">// h为空，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> t.HashMightPanic() &#123;</span><br><span class="line">            t.Hasher(key, <span class="number">0</span>) <span class="comment">// see issue 23734</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 当前有goroutine在写，则返回fatal</span></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    hash := t.Hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">    h.flags ^= hashWriting</span><br><span class="line">    <span class="comment">// 找到对应的桶</span></span><br><span class="line">    bucket := hash &amp; bucketMask(h.B)</span><br><span class="line">  <span class="comment">// 正在扩容，先协助迁移，再删除</span></span><br><span class="line">    <span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">        growWork(t, h, bucket)</span><br><span class="line">    &#125;</span><br><span class="line">    b := (*bmap)(add(h.buckets, bucket*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">    bOrig := b</span><br><span class="line">    top := tophash(hash)</span><br><span class="line">search:</span><br><span class="line">    <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">                <span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">                    <span class="keyword">break</span> search</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">            k2 := k</span><br><span class="line">            <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                k2 = *((*unsafe.Pointer)(k2))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> !t.Key.Equal(key, k2) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Only clear key if there are pointers in it.</span></span><br><span class="line">            <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                *(*unsafe.Pointer)(k) = <span class="literal">nil</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> t.Key.PtrBytes != <span class="number">0</span> &#123;</span><br><span class="line">                memclrHasPointers(k, t.Key.Size_)</span><br><span class="line">            &#125;</span><br><span class="line">            e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.KeySize)+i*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">            <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">                *(*unsafe.Pointer)(e) = <span class="literal">nil</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> t.Elem.PtrBytes != <span class="number">0</span> &#123;</span><br><span class="line">                memclrHasPointers(e, t.Elem.Size_)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                memclrNoHeapPointers(e, t.Elem.Size_)</span><br><span class="line">            &#125;</span><br><span class="line">      <span class="comment">// 更新状态</span></span><br><span class="line">            b.tophash[i] = emptyOne</span><br><span class="line">      <span class="comment">// 没有后一个kv对或者后一个kv对是emptyOne状态，不需要进一步更新状态</span></span><br><span class="line">            <span class="keyword">if</span> i == bucketCnt<span class="number">-1</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> b.overflow(t) != <span class="literal">nil</span> &amp;&amp; b.overflow(t).tophash[<span class="number">0</span>] != emptyRest &#123;</span><br><span class="line">                    <span class="keyword">goto</span> notLast</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> b.tophash[i+<span class="number">1</span>] != emptyRest &#123;</span><br><span class="line">                    <span class="keyword">goto</span> notLast</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> &#123; <span class="comment">// 从后往前，将之前的emptyOne都改为emptyRest</span></span><br><span class="line">                b.tophash[i] = emptyRest</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> b == bOrig &#123;</span><br><span class="line">                        <span class="keyword">break</span> <span class="comment">// beginning of initial bucket, we&#x27;re done.</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    c := b</span><br><span class="line">                    <span class="keyword">for</span> b = bOrig; b.overflow(t) != c; b = b.overflow(t) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    i = bucketCnt - <span class="number">1</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i--</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> b.tophash[i] != emptyOne &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        notLast:</span><br><span class="line">            h.count--</span><br><span class="line">            <span class="keyword">if</span> h.count == <span class="number">0</span> &#123;</span><br><span class="line">                h.hash0 = fastrand()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span> search</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting == <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    h.flags &amp;^= hashWriting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-扩容操作"><a href="#6-扩容操作" class="headerlink" title="6 扩容操作"></a>6 扩容操作</h3><ul><li>等量扩容：负载因子没超过6，但是溢出桶的数量大于等于$1&lt;&lt;min(B,15)$，新桶数组的长度跟旧的一样，相当于是将<code>k-v</code>对重新<code>hash</code></li><li>增量扩容：负载因子超过6，新桶数组的长度是旧的两倍</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashGrow</span><span class="params">(t *maptype, h *hmap)</span></span> &#123;</span><br><span class="line">    bigger := <span class="type">uint8</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 如果是等量扩容</span></span><br><span class="line">    <span class="keyword">if</span> !overLoadFactor(h.count+<span class="number">1</span>, h.B) &#123;</span><br><span class="line">        bigger = <span class="number">0</span></span><br><span class="line">        h.flags |= sameSizeGrow</span><br><span class="line">    &#125;</span><br><span class="line">    oldbuckets := h.buckets</span><br><span class="line">    <span class="comment">// 增量扩容中新桶变为旧桶两倍，等量扩容是数量不变</span></span><br><span class="line">    newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, <span class="literal">nil</span>)</span><br><span class="line">    flags := h.flags &amp;^ (iterator | oldIterator)</span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &#123;</span><br><span class="line">        flags |= oldIterator</span><br><span class="line">    &#125;</span><br><span class="line">    h.B += bigger</span><br><span class="line">    h.flags = flags</span><br><span class="line">    h.oldbuckets = oldbuckets</span><br><span class="line">    h.buckets = newbuckets</span><br><span class="line">    h.nevacuate = <span class="number">0</span></span><br><span class="line">    h.noverflow = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> h.extra != <span class="literal">nil</span> &amp;&amp; h.extra.overflow != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> h.extra.oldoverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;oldoverflow is not nil&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        h.extra.oldoverflow = h.extra.overflow</span><br><span class="line">        h.extra.overflow = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> h.extra == <span class="literal">nil</span> &#123;</span><br><span class="line">            h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">        &#125;</span><br><span class="line">        h.extra.nextOverflow = nextOverflow</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的逻辑还是比较简单，并且<code>hashGrow</code>只在<code>mapassign</code>中出现，就是说只有在新值插入的时候才可能触发扩容。</p><p>下面来分析<code>growWork()</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growWork</span><span class="params">(t *maptype, h *hmap, bucket <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 迁移指定的旧桶</span></span><br><span class="line">    evacuate(t, h, bucket&amp;h.oldbucketmask())</span><br><span class="line">    <span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">    <span class="comment">// 额外再迁移一个桶</span></span><br><span class="line">    <span class="comment">// nevacuate就是记录迁移的进度，所有序号小于这个的桶都已经迁移</span></span><br><span class="line">        evacuate(t, h, h.nevacuate)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为使用的是渐进式扩容，因此在插入和删除操作中，如果此时<code>map</code>正在扩容，则每一个操作都会利用<code>growWork()</code>函数迁移最多两个桶，一个是当时操作的桶，还有一个就是<code>nevacuate</code>指向的桶，另外要注意的是这里的一个桶是包括它所指向的溢出桶的。具体的迁移逻辑在<code>evacuate()</code>函数中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代表了kv对的迁移目的地</span></span><br><span class="line"><span class="keyword">type</span> evacDst <span class="keyword">struct</span> &#123;</span><br><span class="line">    b *bmap          <span class="comment">// 迁移到的目的桶</span></span><br><span class="line">    i <span class="type">int</span>            <span class="comment">// 迁移到的kv对在桶内的序号</span></span><br><span class="line">    k unsafe.Pointer <span class="comment">// 迁移到的kv对的key位置</span></span><br><span class="line">    e unsafe.Pointer <span class="comment">// 迁移到的kv对的value位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// oldbucket表示要迁移的桶序号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evacuate</span><span class="params">(t *maptype, h *hmap, oldbucket <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    b := (*bmap)(add(h.oldbuckets, oldbucket*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">    newbit := h.noldbuckets()<span class="comment">// 旧桶个数</span></span><br><span class="line">    <span class="keyword">if</span> !evacuated(b) &#123;</span><br><span class="line">        <span class="keyword">var</span> xy [<span class="number">2</span>]evacDst<span class="comment">// 新桶的前一半和后一半</span></span><br><span class="line">        x := &amp;xy[<span class="number">0</span>]</span><br><span class="line">        x.b = (*bmap)(add(h.buckets, oldbucket*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">        x.k = add(unsafe.Pointer(x.b), dataOffset)</span><br><span class="line">        x.e = add(x.k, bucketCnt*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">        <span class="comment">// 增量扩容，有后一半</span></span><br><span class="line">        <span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">            y := &amp;xy[<span class="number">1</span>]</span><br><span class="line">            y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">            y.k = add(unsafe.Pointer(y.b), dataOffset)</span><br><span class="line">            y.e = add(y.k, bucketCnt*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前面已经将要迁移到的位置记录下来</span></span><br><span class="line">        <span class="comment">// 将这个桶及其溢出桶都迁移</span></span><br><span class="line">        <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset)</span><br><span class="line">            e := add(k, bucketCnt*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; bucketCnt; i, k, e = i+<span class="number">1</span>, add(k, <span class="type">uintptr</span>(t.KeySize)), add(e, <span class="type">uintptr</span>(t.ValueSize)) &#123;</span><br><span class="line">                top := b.tophash[i]</span><br><span class="line">                <span class="comment">// 当前位置已完成迁移，状态置为evacuatedEmpty</span></span><br><span class="line">                <span class="keyword">if</span> isEmpty(top) &#123;</span><br><span class="line">                    b.tophash[i] = evacuatedEmpty</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">                    throw(<span class="string">&quot;bad map state&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                k2 := k</span><br><span class="line">                <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                    k2 = *((*unsafe.Pointer)(k2))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">var</span> useY <span class="type">uint8</span></span><br><span class="line">                <span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">                    hash := t.Hasher(k2, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">                    <span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &amp;&amp; !t.ReflexiveKey() &amp;&amp; !t.Key.Equal(k2, k2) &#123;</span><br><span class="line">                        useY = top &amp; <span class="number">1</span></span><br><span class="line">                        top = tophash(hash)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 判断第n+1位是否等于1，后面n位跟旧桶一样</span></span><br><span class="line">                        <span class="keyword">if</span> hash&amp;newbit != <span class="number">0</span> &#123;</span><br><span class="line">                            useY = <span class="number">1</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> evacuatedX+<span class="number">1</span> != evacuatedY || evacuatedX^<span class="number">1</span> != evacuatedY &#123;</span><br><span class="line">                    throw(<span class="string">&quot;bad evacuatedN&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                b.tophash[i] = evacuatedX + useY <span class="comment">// evacuatedX + 1 == evacuatedY</span></span><br><span class="line">                dst := &amp;xy[useY]                 <span class="comment">// 迁移目的地</span></span><br><span class="line">                <span class="comment">// 目的桶8个kv对满了</span></span><br><span class="line">                <span class="keyword">if</span> dst.i == bucketCnt &#123;</span><br><span class="line">          <span class="comment">// 生成一个新的溢出桶</span></span><br><span class="line">                    dst.b = h.newoverflow(t, dst.b)</span><br><span class="line">                    dst.i = <span class="number">0</span></span><br><span class="line">                    dst.k = add(unsafe.Pointer(dst.b), dataOffset)</span><br><span class="line">                    dst.e = add(dst.k, bucketCnt*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">                &#125;</span><br><span class="line">                dst.b.tophash[dst.i&amp;(bucketCnt<span class="number">-1</span>)] = top <span class="comment">// mask dst.i as an optimization, to avoid a bounds check</span></span><br><span class="line">                <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                    *(*unsafe.Pointer)(dst.k) = k2 <span class="comment">// copy pointer</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    typedmemmove(t.Key, dst.k, k) <span class="comment">// copy elem</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">                    *(*unsafe.Pointer)(dst.e) = *(*unsafe.Pointer)(e)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    typedmemmove(t.Elem, dst.e, e)</span><br><span class="line">                &#125;</span><br><span class="line">                dst.i++</span><br><span class="line">                dst.k = add(dst.k, <span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">                dst.e = add(dst.e, <span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> h.flags&amp;oldIterator == <span class="number">0</span> &amp;&amp; t.Bucket.PtrBytes != <span class="number">0</span> &#123;</span><br><span class="line">            b := add(h.oldbuckets, oldbucket*<span class="type">uintptr</span>(t.BucketSize))</span><br><span class="line">            ptr := add(b, dataOffset)</span><br><span class="line">            n := <span class="type">uintptr</span>(t.BucketSize) - dataOffset</span><br><span class="line">            memclrHasPointers(ptr, n)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> oldbucket == h.nevacuate &#123;</span><br><span class="line">        advanceEvacuationMark(h, t, newbit)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下为什么增量扩容，旧桶只会出现在新桶的两个位置</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230831213704412.png" alt="image-20230831213704412"></p><p>迁移完<code>nevacuate</code>桶后，它会+1，这个时候可能+1的这个桶之前被迁移过了，所以需要继续往后找到一个还未没迁移的桶，该逻辑在<code>advanceEvacuationMark</code>函数中：</p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230831213326389.png" alt="image-20230831213326389" style="zoom:40%;" /><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">advanceEvacuationMark</span><span class="params">(h *hmap, t *maptype, newbit <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    h.nevacuate++</span><br><span class="line">    <span class="comment">// 往后最多看1024个桶</span></span><br><span class="line">    stop := h.nevacuate + <span class="number">1024</span></span><br><span class="line">    <span class="comment">// newbit是旧桶的数量</span></span><br><span class="line">    <span class="keyword">if</span> stop &gt; newbit &#123;</span><br><span class="line">        stop = newbit</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将nevacuate指向第一个未迁移的桶</span></span><br><span class="line">    <span class="keyword">for</span> h.nevacuate != stop &amp;&amp; bucketEvacuated(t, h, h.nevacuate) &#123;</span><br><span class="line">        h.nevacuate++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果所有旧桶全部迁移完</span></span><br><span class="line">    <span class="keyword">if</span> h.nevacuate == newbit &#123; <span class="comment">// newbit == # of oldbuckets</span></span><br><span class="line">    <span class="comment">// 释放旧桶</span></span><br><span class="line">        h.oldbuckets = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> h.extra != <span class="literal">nil</span> &#123;</span><br><span class="line">            h.extra.oldoverflow = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 将迁移标志清除，结束扩容状态</span></span><br><span class="line">        h.flags &amp;^= sameSizeGrow</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码解读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>channel源码学习</title>
      <link href="/2023/08/27/channel%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/08/27/channel%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>特别提醒，本文所涉及的源码是<code>go1.21.0 darwin/amd64</code></p><p>文件位置：runtime&#x2F;trace&#x2F;chan.go</p></blockquote><h3 id="1-基本数据结构"><a href="#1-基本数据结构" class="headerlink" title="1 基本数据结构"></a>1 基本数据结构</h3><h4 id="1-1hchan"><a href="#1-1hchan" class="headerlink" title="1.1hchan"></a>1.1hchan</h4><p><code>Go</code>语言的<code>channel</code>在运行时使用<code>runtime.hchan</code>结构体来表示，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="type">uint</span>           <span class="comment">// 已经存放的元素个数</span></span><br><span class="line">    dataqsiz <span class="type">uint</span>           <span class="comment">// 容量</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// 存放元素的环形缓冲区</span></span><br><span class="line">    elemsize <span class="type">uint16</span><span class="comment">// 元素类型的大小</span></span><br><span class="line">    closed   <span class="type">uint32</span><span class="comment">// channel是否关闭</span></span><br><span class="line">    elemtype *_type <span class="comment">// 元素类型</span></span><br><span class="line">    sendx    <span class="type">uint</span>   <span class="comment">// channel发送操作处理的位置</span></span><br><span class="line">    recvx    <span class="type">uint</span>   <span class="comment">// channel接收操作处理的位置</span></span><br><span class="line">    recvq    waitq  <span class="comment">// 因接收而陷入阻塞的协程队列，即（ &lt;-ch ）</span></span><br><span class="line">    sendq    waitq  <span class="comment">// 因发送而陷入阻塞的协程队列，即（ ch&lt;- ）</span></span><br><span class="line"></span><br><span class="line">    lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-waitq"><a href="#1-2-waitq" class="headerlink" title="1.2 waitq"></a>1.2 waitq</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻塞的协程队列，是一个双向链表</span></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">    first *sudog<span class="comment">// 表头</span></span><br><span class="line">    last  *sudog<span class="comment">// 表尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-sudog"><a href="#1-3-sudog" class="headerlink" title="1.3 sudog"></a>1.3 sudog</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">    g *g</span><br><span class="line">    next *sudog</span><br><span class="line">    prev *sudog</span><br><span class="line">    elem unsafe.Pointer <span class="comment">// 指向数据元素 (可能指向栈)</span></span><br><span class="line">    acquiretime <span class="type">int64</span></span><br><span class="line">    releasetime <span class="type">int64</span></span><br><span class="line">    ticket      <span class="type">uint32</span></span><br><span class="line">    isSelect <span class="type">bool</span></span><br><span class="line">    success  <span class="type">bool</span></span><br><span class="line">    parent   *sudog <span class="comment">// semaRoot 二叉树</span></span><br><span class="line">    waitlink *sudog <span class="comment">// g.waiting list or semaRoot</span></span><br><span class="line">    waittail *sudog <span class="comment">// semaRoot</span></span><br><span class="line">    c        *hchan <span class="comment">// channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>sudog：对<code>goroutine</code>的封装，表示一个在等待队列中的<code>g</code></p></li><li><p>g：协程</p></li><li><p>next：链表的下一个节点</p></li><li><p>prev：链表的前一个节点</p></li><li><p>elem：指向数据</p></li><li><p>isSelect：表示<code>g</code>是否被选择</p></li><li><p>success：表示<code>channel</code>c上的通信是否成功</p></li></ul><p>直接看数据结构的定义，可能会有点不理解，下面通过图来辅助理解</p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230825143137015.png" alt="image-20230825143137015"></p><blockquote><p>图片来源:<a href="https://halfrost.com/go_channel/#toc-6">https://halfrost.com/go_channel/#toc-6</a></p></blockquote><p>其中<code>sendx</code>可能指向的是<code>5</code>边上那块还没有数据的区域，即如果执行ch &lt;- data$，那么<code>data</code>将被存储到这块区域。</p><p>同理<code>recvx</code>指向的是<code>0</code>，如果执行<code>&lt;-ch</code>首先会得到0，然后<code>recvx</code>会指向下一个</p><p>如果<code>buf</code>中存放的元素已经达到容量，此时还有<code>g</code>在执行发送操作给<code>ch</code>的话，即<code>ch&lt;-data</code>则会被添加到<code>sendq</code>队列中去，直到通道中的元素不再是满的。</p><p>同理<code>buf</code>是空的， 此时还有<code>g</code>在执行接收操作的话，即<code>&lt;-ch</code>则会被添加到<code>recvq</code>队列中去，直到通道中有元素。</p><h3 id="2-创建channel"><a href="#2-创建channel" class="headerlink" title="2 创建channel"></a>2 创建channel</h3><p>创建<code>channel</code>的函数有两个，原型如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan64</span><span class="params">(t *chantype, size <span class="type">int64</span>)</span></span> *hchan</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan</span><br></pre></td></tr></table></figure><p><code>makechan64</code>方法只是判断一下传入的<code>size</code>是否在<code>int32</code>范围内</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan64</span><span class="params">(t *chantype, size <span class="type">int64</span>)</span></span> *hchan &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="type">int64</span>(<span class="type">int</span>(size)) != size &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> makechan(t, <span class="type">int</span>(size))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的实现还是在<code>makechan</code>中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;</span><br><span class="line">    elem := t.Elem</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译器检查单个元素的大小不能超过64KB</span></span><br><span class="line">    <span class="keyword">if</span> elem.Size_ &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;makechan: invalid channel element type&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 检查是否对齐</span></span><br><span class="line">    <span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.Align_ &gt; maxAlign &#123;</span><br><span class="line">        throw(<span class="string">&quot;makechan: bad alignment&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓冲区大小检查，判断是否溢出</span></span><br><span class="line">    mem, overflow := math.MulUintptr(elem.Size_, <span class="type">uintptr</span>(size))</span><br><span class="line">    <span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> c *hchan</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> mem == <span class="number">0</span>:</span><br><span class="line">        <span class="comment">// 队列或者元素大小为0时</span></span><br><span class="line">        c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">        <span class="comment">// Rac 竞争检查使用这个地址进行同步操作</span></span><br><span class="line">        c.buf = c.raceaddr()</span><br><span class="line">    <span class="keyword">case</span> elem.PtrBytes == <span class="number">0</span>:</span><br><span class="line">        <span class="comment">// 元素不包含指针时，一次性分配hchan和buf的内存</span></span><br><span class="line">        c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">        c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 元素包含指针时,则分别申请hchan和buf的空间，两者无需连续</span></span><br><span class="line">        c = <span class="built_in">new</span>(hchan)</span><br><span class="line">        c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将其余字段赋初始值</span></span><br><span class="line">    c.elemsize = <span class="type">uint16</span>(elem.Size_)</span><br><span class="line">    c.elemtype = elem</span><br><span class="line">    c.dataqsiz = <span class="type">uint</span>(size)</span><br><span class="line">    lockInit(&amp;c.lock, lockRankHchan)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debugChan &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;makechan: chan=&quot;</span>, c, <span class="string">&quot;; elemsize=&quot;</span>, elem.Size_, <span class="string">&quot;; dataqsiz=&quot;</span>, size, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-发送数据"><a href="#3-发送数据" class="headerlink" title="3 发送数据"></a>3 发送数据</h3><p>发送数据的操作有两个函数<code>chansend1()</code>和<code>chansend()</code>，不过实现逻辑都在后者，所以直接看它怎么实现的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="comment">// 判断 channel 是否为nil</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceBlockForever, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">  lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先对<code>channel</code>进行检查，如果已经被<code>GC</code>回收，往一个<code>nil</code>的通道发送数据会发送阻塞。<code>gopark</code>会引发以waitReasonChanSendNilChan为原因的休眠，并抛出一个<code>unreachable</code>的错误。</li><li>其次向已经关闭的<code>channel</code>发送数据时会报”send on closed channel”的错误</li></ul><p>下面将发送过程分为三种情况</p><h4 id="3-1-写时存在阻塞的读协程——直接发送"><a href="#3-1-写时存在阻塞的读协程——直接发送" class="headerlink" title="3.1 写时存在阻塞的读协程——直接发送"></a>3.1 写时存在阻塞的读协程——直接发送</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果存在阻塞的读协程时，会直接从<code>recvq</code>中取出最先陷入等待（遵循FIFO原则）的<code>Goroutine</code>并直接向它发送数据，绕过缓冲区</p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230825220928571.png" alt="image-20230825220928571" style="zoom:33%;" /><p>发送时的具体的执行逻辑由<code>send()</code>函数来完成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">        sendDirect(c.elemtype, sg, ep)</span><br><span class="line">        sg.elem = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    gp := sg.g</span><br><span class="line">    unlockf()</span><br><span class="line">    gp.param = unsafe.Pointer(sg)</span><br><span class="line">    sg.success = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">        sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>send()</code>函数主要完成了2件事情：</p><ol><li>调用<code>sendDirect()</code>函数将发送的数据直接拷贝到<code>x = &lt;-ch</code>表达式中变量<code>x</code>所在的内存地址上，使用的是<code>memmove()</code>函数。</li><li>调用<code>goready()</code>将等待接收的<code>g</code>的状态从<code>Gwaiting</code>或者<code>Gscanwaiting</code>变成<code>Grunnable</code>，并把该<code>g</code>放到<code>runnext</code>中，处理器在下一次调度时会立即运行它，具体逻辑可以看<code>runqput()</code>函数的代码。需要注意是，<strong>发送数据的过程并没有立即执行接收发的<code>g</code>，只是将<code>g</code>放到<code>runnext</code>中，下一次调度的时候再执行。</strong></li></ol><h4 id="3-2-channel带有缓冲区，空间还未满并且不存在阻塞的读协程"><a href="#3-2-channel带有缓冲区，空间还未满并且不存在阻塞的读协程" class="headerlink" title="3.2 channel带有缓冲区，空间还未满并且不存在阻塞的读协程"></a>3.2 channel带有缓冲区，空间还未满并且不存在阻塞的读协程</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">        qp := chanbuf(c, c.sendx)</span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            racenotify(c, c.sendx, <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">        c.sendx++</span><br><span class="line">        <span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">            c.sendx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.qcount++</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果 <code>qcount</code>还没有满，则调用<code> chanbuf()</code> 获取 <code>sendx</code> 索引的元素指针值。调用 <code>typedmemmove()</code> 方法将发送的值拷贝到缓冲区 <code>buf</code> 中。拷贝完成，需要维护 <code>sendx </code>索引下标值和<code> qcount</code> 个数。这里将 <code>buf</code> 缓冲区设计成环形的，索引值如果到了队尾，下一个位置重新回到队头。</p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230826133707785.png" alt="image-20230826133707785" style="zoom:50%;" /><blockquote><p>图片来源：<a href="https://halfrost.com/go_channel/#toc-10">https://halfrost.com/go_channel/#toc-10</a></p></blockquote><h4 id="3-3-channel带有缓冲区，空间已满并且不存在阻塞的读协程"><a href="#3-3-channel带有缓冲区，空间已满并且不存在阻塞的读协程" class="headerlink" title="3.3 channel带有缓冲区，空间已满并且不存在阻塞的读协程"></a>3.3 channel带有缓冲区，空间已满并且不存在阻塞的读协程</h4><p>这时向<code>channel</code>发送数据会进入阻塞状态</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">gp := getg()</span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">    mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.waiting = mysg</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">c.sendq.enqueue(mysg)</span><br><span class="line">gp.parkingOnChan.Store(<span class="literal">true</span>)</span><br><span class="line">gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceBlockChanSend, <span class="number">2</span>)</span><br><span class="line">KeepAlive(ep)</span><br></pre></td></tr></table></figure><ul><li><p>调用<code>getg()</code>方法获取当前<code>g</code>的指针，绑定到一个<code>sudog</code>上</p></li><li><p>调用<code>acquireSudog()</code>方法获取一个<code>sudog</code></p></li><li><p>调用<code>c.sendq.enqueue()</code>方法将配置好的<code>sudog</code>加入队列</p></li><li><p>调用<code>gopark()</code>挂起当前<code>g</code>，状态为<code>waitReasonChanSend</code>，阻塞等待<code>channel</code>发送</p></li><li><p>调用<code>KeepAlive()</code>保持活动状态，等待其它协程取走元素</p></li></ul><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230826135153228.png" alt="image-20230826135153228" style="zoom:50%;" /><blockquote><p>图片来源：<a href="https://halfrost.com/go_channel/#toc-10">https://halfrost.com/go_channel/#toc-10</a></p></blockquote><h3 id="4-接收数据"><a href="#4-接收数据" class="headerlink" title="4 接收数据"></a>4 接收数据</h3><p>接收数据的实现是在<code>chanrecv()</code>函数下实现的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从一个为nil的通道中接收数据会发生异常</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceBlockForever, <span class="number">2</span>)</span><br><span class="line">    throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通道已经关闭且不存在缓存数据也会异常</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquire(c.raceaddr())</span><br><span class="line">        &#125;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemclr(c.elemtype, ep)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-读时存在阻塞的写协程"><a href="#4-1-读时存在阻塞的写协程" class="headerlink" title="4.1 读时存在阻塞的写协程"></a>4.1 读时存在阻塞的写协程</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>从阻塞的<code>sendq</code>中获取头部的<code>g</code></li><li>如果缓冲区大小为0，则直接读取写协程元素，并唤醒它，这种情况只会发生一次<code>copy</code>操作即将阻塞的<code>g</code>所保存的元素复制到<code>read</code></li></ul><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230826151104338.png" alt="image-20230826151104338" style="zoom:50%;" /><ul><li>如果有缓冲区，则读取头部元素，并将处于等待发送的<code>g</code>的元素写入缓冲区的尾部（即刚刚读取的位置，因为是环形的），这种情况会发送两次<code>copy</code>操作，先将缓冲区<code>recvx</code>处的元素拷贝到<code>read</code>，然后将阻塞的<code>g</code>的元素拷贝到<code>sendx</code>所处的地址。</li></ul><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230826150504865.png" alt="image-20230826150504865" style="zoom:40%;" /><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230826151355877.png" alt="image-20230826151355877" style="zoom:40%;" /><blockquote><p>图片来源：<a href="https://halfrost.com/go_channel/#toc-16">https://halfrost.com/go_channel/#toc-16</a></p></blockquote><h4 id="4-2-读取时无阻塞的写协程且缓冲区有元素"><a href="#4-2-读取时无阻塞的写协程且缓冲区有元素" class="headerlink" title="4.2 读取时无阻塞的写协程且缓冲区有元素"></a>4.2 读取时无阻塞的写协程且缓冲区有元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">        qp := chanbuf(c, c.recvx)</span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            racenotify(c, c.recvx, <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">        &#125;</span><br><span class="line">        typedmemclr(c.elemtype, qp)</span><br><span class="line">        c.recvx++</span><br><span class="line">        <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">            c.recvx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.qcount--</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>直接将<code>recvx</code>处的元素拷贝给<code>read</code>，然后将对应的属性操作，<code>qcount</code>减1，<code>recvx</code>++，如果等于容量，则归0，可以理解为取模操作<code>(recvx++)%qcount</code></p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230826151746532.png" alt="image-20230826151746532" style="zoom:40%;" /><h4 id="4-3-读时没有阻塞的写协程且缓冲区无元素"><a href="#4-3-读时没有阻塞的写协程且缓冲区无元素" class="headerlink" title="4.3 读时没有阻塞的写协程且缓冲区无元素"></a>4.3 读时没有阻塞的写协程且缓冲区无元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">gp := getg()</span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">    mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">gp.waiting = mysg</span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">c.recvq.enqueue(mysg)</span><br><span class="line">gp.parkingOnChan.Store(<span class="literal">true</span>)</span><br><span class="line">gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanReceive, traceBlockChanRecv, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><ul><li><p>调用<code>getg()</code>方法获取当前<code>g</code>的指针，绑定到一个<code>sudog</code>上</p></li><li><p>调用<code>acquireSudog()</code>方法获取一个<code>sudog</code></p></li><li><p>调用<code>c.recvq.enqueue()</code>方法将配置好的<code>sudog</code>加入队列</p></li><li><p>调用<code>gopark()</code>挂起当前<code>g</code>，状态为<code>waitReasonChanReceive</code>，阻塞等待<code>channel</code>接收</p></li></ul><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230826152412808.png" alt="image-20230826152412808" style="zoom:50%;" /><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230826152442123.png" alt="image-20230826152442123" style="zoom:40%;" /><blockquote><p>图片来源<a href="https://halfrost.com/go_channel/#toc-16">https://halfrost.com/go_channel/#toc-16</a></p></blockquote><h3 id="5-关闭Channel"><a href="#5-关闭Channel" class="headerlink" title="5 关闭Channel"></a>5 关闭Channel</h3><p>关闭通道的实现在<code>closechan()</code>函数中:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;close of nil channel&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;close of closed channel&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        callerpc := getcallerpc()</span><br><span class="line">        racewritepc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(closechan))</span><br><span class="line">        racerelease(c.raceaddr())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.closed = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>当关闭<code>channel</code>是<code>nil</code>或者是一个已经关闭的<code>channel</code>时，会直接<code>panic</code>，当不存在这两种情况的时候，标记<code>channel</code>状态为<code>close</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> glist gList</span><br><span class="line"><span class="comment">// release all readers</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    sg := c.recvq.dequeue()</span><br><span class="line">    <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">        typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">        sg.elem = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">        sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    gp := sg.g</span><br><span class="line">    gp.param = unsafe.Pointer(sg)</span><br><span class="line">    sg.success = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        raceacquireg(gp, c.raceaddr())</span><br><span class="line">    &#125;</span><br><span class="line">    glist.push(gp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>recvq</code>队列中的<code>sudog</code>加入到待清除的队列<code>glist</code>中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// release all writers (they will panic)</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        sg := c.sendq.dequeue()</span><br><span class="line">        <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        sg.elem = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">            sg.releasetime = cputicks()</span><br><span class="line">        &#125;</span><br><span class="line">        gp := sg.g</span><br><span class="line">        gp.param = unsafe.Pointer(sg)</span><br><span class="line">        sg.success = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquireg(gp, c.raceaddr())</span><br><span class="line">        &#125;</span><br><span class="line">        glist.push(gp)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;c.lock)</span><br></pre></td></tr></table></figure><p>将<code>sendq</code>队列中的<code>sudog</code>加入到待清除的队列<code>glist</code>中，这里可能会产生<code>panic</code></p><p><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230826153540944.png" alt="image-20230826153540944"></p><blockquote><p>图片来源：<a href="https://halfrost.com/go_channel/#toc-16">https://halfrost.com/go_channel/#toc-16</a></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">        gp := glist.pop()</span><br><span class="line">        gp.schedlink = <span class="number">0</span></span><br><span class="line">        goready(gp, <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后会为所有被阻塞的 <code>g</code> 调用<code> goready</code> 触发调度。将所有<code>glist</code>中的<code> g</code> 状态从<code>_Gwaiting</code>设置为 <code>_Grunnable </code>状态，等待调度器的调度。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://speakerdeck.com/kavya719/understanding-channels?slide=32">kavya’s Understanding Channels</a></li><li><a href="https://halfrost.com/go_channel/#toc-0">https://halfrost.com/go_channel/#toc-0</a></li><li><a href="https://mp.weixin.qq.com/s/QgNndPgN1kqxWh-ijSofkw">https://mp.weixin.qq.com/s/QgNndPgN1kqxWh-ijSofkw</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码解读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Context源码解读</title>
      <link href="/2023/08/23/Context%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
      <url>/2023/08/23/Context%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>特别提醒，本文所涉及的源码是<code>go1.21.0 darwin/amd64</code></p></blockquote><h3 id="1-什么是Context"><a href="#1-什么是Context" class="headerlink" title="1. 什么是Context"></a>1. 什么是Context</h3><p>在多个goroutine之间传递上下文的对象，传递的信息包括取消信号、截止时间以及其他一些跨api边界的值</p><h3 id="2-核心数据结构"><a href="#2-核心数据结构" class="headerlink" title="2. 核心数据结构"></a>2. 核心数据结构</h3><h4 id="2-1-Context"><a href="#2-1-Context" class="headerlink" title="2.1 Context"></a>2.1 Context</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line">    Value(key any) any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Context</code>定义为<code>Interface</code>，定义了4个核心函数：</p><ul><li>Dealine：返回<code>context</code>的过期时间和一个<code>bool</code>值判断是否设置了deadline</li><li>Done：返回<code>context</code>中的<code>channel</code>，该<code>channel</code>会在当前工作完成或者上下文被取消后关闭，多次调用返回的是同一个<code>channel</code>，如果该<code>context</code>是不能被取消的，则会返回<code>nil</code></li><li>Err：返回<code>context</code>结束的原因</li><li>Value：返回<code>contxet</code>中存储的key对应的值</li></ul><h4 id="2-2-error"><a href="#2-2-error" class="headerlink" title="2.2 error"></a>2.2 error</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Canceled = errors.New(<span class="string">&quot;context canceled&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DeadlineExceeded <span class="type">error</span> = deadlineExceededError&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> deadlineExceededError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Error() <span class="type">string</span>   &#123; <span class="keyword">return</span> <span class="string">&quot;context deadline exceeded&quot;</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Timeout() <span class="type">bool</span>   &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Temporary() <span class="type">bool</span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><ul><li>Canceled：<code>context</code>被cancel时会返回该类错误</li><li>DeadlineExceeded：<code>context</code>超时时会返回该类错误</li></ul><h3 id="3-具体实现"><a href="#3-具体实现" class="headerlink" title="3 具体实现"></a>3 具体实现</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230823100804205.png" alt="image-20230823100804205" style="zoom: 33%;" /></h3><h4 id="3-1-emptyCtx"><a href="#3-1-emptyCtx" class="headerlink" title="3.1 emptyCtx"></a>3.1 emptyCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(emptyCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(emptyCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(emptyCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(emptyCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>emptyCtx</code>是一个空的<code>context</code>，之前的一些版本中是直接将它定义为一个<code>int</code>类型</p><h4 id="3-2-backgroundCtx"><a href="#3-2-backgroundCtx" class="headerlink" title="3.2 backgroundCtx"></a>3.2 backgroundCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> backgroundCtx <span class="keyword">struct</span>&#123; emptyCtx &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(backgroundCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;context.Background&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">    <span class="keyword">return</span> backgroundCtx&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Background()</code>返回一个非nil但是为空的<code>context</code>。它不能被取消，没有任何值，也没有截止时间。通常被主函数、初始化、测试以及作为传入请求的顶层<code>context</code>使用。</p><h4 id="3-3-todoCtx"><a href="#3-3-todoCtx" class="headerlink" title="3.3 todoCtx"></a>3.3 todoCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> todoCtx <span class="keyword">struct</span>&#123; emptyCtx &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(todoCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;context.TODO&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">    <span class="keyword">return</span> todoCtx&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TODO()</code>同样返回一个非nil但是为空的<code>context</code>。在代码不清楚应该使用哪个上下文或者上下文尚不可用时，应该使用<code>context.TODO</code></p><h4 id="3-4-cancelCtx"><a href="#3-4-cancelCtx" class="headerlink" title="3.4 cancelCtx"></a>3.4 cancelCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    Context</span><br><span class="line"></span><br><span class="line">    mu       sync.Mutex            <span class="comment">// protects following fields</span></span><br><span class="line">    done     atomic.Value          <span class="comment">// of chan struct&#123;&#125;, created lazily, closed by first cancel call</span></span><br><span class="line">    children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">    err      <span class="type">error</span>                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">    cause    <span class="type">error</span>                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cancelCtx</code>是取消机制的关键</p><ul><li><p>其结构体嵌入了一个&#96;Context，作为其父类</p></li><li><p>mu：内置一把锁，用于多goroutine并发场景下的资源获取</p></li><li><p>done：原子类型的值，实际类型为<code>chan struct&#123;&#125;</code>，用来反应<code>cancelCtx</code>的生命周期</p></li><li><p>children：一个集合，保存了所有该<code>cancelCtx</code>的子<code>context</code></p></li><li><p>err：记录<code>cancelCtx</code>发生的错误</p></li><li><p>cause：记录<code>calcelCtx</code>被取消的原因</p></li></ul><h5 id="3-4-1-Value方法"><a href="#3-4-1-Value方法" class="headerlink" title="3.4.1 Value方法"></a>3.4.1 Value方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &amp;cancelCtxKey is the key that a cancelCtx returns itself for.</span></span><br><span class="line"><span class="keyword">var</span> cancelCtxKey <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">    <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">        <span class="keyword">return</span> c</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value(c.Context, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>key</code>的值为<code>&amp;cancelCtxKey</code>，则返回<code>cancelCtx</code>本身的指针，否则返回对应<code>key</code>存储的<code>value</code>值</p><h5 id="3-4-2-Done方法"><a href="#3-4-2-Done方法" class="headerlink" title="3.4.2 Done方法"></a>3.4.2 Done方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">    d := c.done.Load()</span><br><span class="line">    <span class="keyword">if</span> d != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> d.(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    d = c.done.Load()</span><br><span class="line">    <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">        d = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">        c.done.Store(d)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d.(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>前面提到<code>done</code>属性是一个原子类型的值,因此通过<code>atomic</code>包中的<code>Load()</code>函数获取它的值,如果它已经存在则直接返回</li><li>如果不存在则先加锁，然后创建一个新的<code>chan struct&#123;&#125;</code>，然后通过<code>Store()</code>赋值给<code>done</code>，可以看到这是一个懒加载机制，在第一次调用<code>c.Done()</code>的时候，该属性才被创建，返回值，然后解锁</li></ul><h5 id="3-4-3-Err方法"><a href="#3-4-3-Err方法" class="headerlink" title="3.4.3 Err方法"></a>3.4.3 Err方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    err := c.err</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加锁、读取值、解锁、返回结果</p><h5 id="3-4-4-propagateCancel方法"><a href="#3-4-4-propagateCancel方法" class="headerlink" title="3.4.4 propagateCancel方法"></a>3.4.4 propagateCancel方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> propagateCancel(parent Context, child canceler) &#123;</span><br><span class="line">    c.Context = parent</span><br><span class="line"></span><br><span class="line">    done := parent.Done()</span><br><span class="line">    <span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-done:</span><br><span class="line">        <span class="comment">// parent is already canceled</span></span><br><span class="line">        child.cancel(<span class="literal">false</span>, parent.Err(), Cause(parent))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">        <span class="comment">// parent is a *cancelCtx, or derives from one.</span></span><br><span class="line">        p.mu.Lock()</span><br><span class="line">        <span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// parent has already been canceled</span></span><br><span class="line">            child.cancel(<span class="literal">false</span>, p.err, p.cause)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">                p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> a, ok := parent.(afterFuncer); ok &#123;</span><br><span class="line">        <span class="comment">// parent implements an AfterFunc method.</span></span><br><span class="line">        c.mu.Lock()</span><br><span class="line">        stop := a.AfterFunc(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            child.cancel(<span class="literal">false</span>, parent.Err(), Cause(parent))</span><br><span class="line">        &#125;)</span><br><span class="line">        c.Context = stopCtx&#123;</span><br><span class="line">            Context: parent,</span><br><span class="line">            stop:    stop,</span><br><span class="line">        &#125;</span><br><span class="line">        c.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    goroutines.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">            child.cancel(<span class="literal">false</span>, parent.Err(), Cause(parent))</span><br><span class="line">        <span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法比较关键，会构建父子上下文之间的关联，当父上下文被取消时，子上下文也会被取消，不会出现状态不一致的情况</p><ul><li>首先将<code>parent</code>赋值给<code>Context</code>属性</li><li>如果父上下文不会取消，则直接返回</li><li>如果父上下文已经取消，则直接终止子上下文</li><li>如果父上下文是可以取消的上下文类型，即<code>cancelCtx</code>，则先加锁、然后将其加入到父上下文的<code>children</code>中，最后解锁</li><li>如果父上下文实现了<code>AfterFunc</code>方法，则在上下文被取消后，将子上下文也取消，通过调用一个<code>stop()</code>函数来实现的</li><li>如果都没满足前面的条件，则启动一个协程监控parent状态，倘若父上下文终止，则终止子上下文</li></ul><blockquote><p>进一步观察<code>parentCancelCtx</code>是如何校验<code>parent</code>是否为<code>cancelCtx</code>类型的</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> closedchan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">close</span>(closedchan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span></span> (*cancelCtx, <span class="type">bool</span>) &#123;</span><br><span class="line">    done := parent.Done()</span><br><span class="line">    <span class="keyword">if</span> done == closedchan || done == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    p, ok := parent.Value(&amp;cancelCtxKey).(*cancelCtx)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    pdone, _ := p.done.Load().(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> pdone != done &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>closedchan</code>表示一个已经关闭的通道</li><li>倘若<code>parent</code>的<code>channel</code>已经被关闭或者是不会被<code>cancel</code>的类型，则直接返回<code>false</code></li><li>倘若用<code>&amp;cancelCtxKey</code>能取到值并且得到的值是<code>parent</code>本身,返回<code>true</code>（<code>cancelCtx</code>的约定，<code>key</code>为<code>&amp;cancelCtxKey</code>的时候，返回的是<code>cancelCtx</code>本身的指针）</li></ul><h5 id="3-4-5-String方法"><a href="#3-4-5-String方法" class="headerlink" title="3.4.5 String方法"></a>3.4.5 String方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> contextName(c.Context) + <span class="string">&quot;.WithCancel&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回<code>cancelCtx</code>的名字</p><h5 id="3-4-6-cancel方法"><a href="#3-4-6-cancel方法" class="headerlink" title="3.4.6 cancel方法"></a>3.4.6 cancel方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err, cause <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;context: internal error: missing cancel error&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> cause == <span class="literal">nil</span> &#123;</span><br><span class="line">        cause = err</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// already canceled</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.err = err</span><br><span class="line">    c.cause = cause</span><br><span class="line">    d, _ := c.done.Load().(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">        c.done.Store(closedchan)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">close</span>(d)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> acquiring the child&#x27;s lock while holding parent&#x27;s lock.</span></span><br><span class="line">        child.cancel(<span class="literal">false</span>, err, cause)</span><br><span class="line">    &#125;</span><br><span class="line">    c.children = <span class="literal">nil</span></span><br><span class="line">    c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">        removeChild(c.Context, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>该方法接收三个参数，<code>removeFromParent</code>是一个<code>bool</code>值，表示需要从当前<code>context</code>的父<code>context</code>的<code>children</code>中删除</li><li>加锁，判断自己的<code>err</code>是否为空，如果不为空，说明已经被<code>cancel</code>，直接返回</li><li>处理 <code>cancelCtx</code> 的 <code>channel</code>，若<code> channel</code> 此前未初始化，则直接注入一个 <code>closedChan</code>，否则关闭该 <code>channel</code></li><li>遍历该<code>cancelCtx</code>的子<code>context</code>，依次将其<code>cancel</code></li><li>解锁，最后根据传入的参数<code>removeFromParent</code>，判断是否需要手动把 <code>cancelCtx</code> 从 <code>parent</code> 的<code> children</code> 集合中移除</li></ul><blockquote><p>走进 <code>removeChild</code> 方法中，观察如何将 <code>cancelCtx</code> 从<code> parent</code> 的<code> children</code> 集合 中移除：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeChild</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s, ok := parent.(stopCtx); ok &#123;</span><br><span class="line">        s.stop()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    p, ok := parentCancelCtx(parent)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    p.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> p.children != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">delete</span>(p.children, child)</span><br><span class="line">    &#125;</span><br><span class="line">    p.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果<code>parent</code>不是<code>cancelCtx</code>类型的，则直接返回（因为只有 <code>cancelCtx</code> 才有 <code>children</code>集合）</li><li>加锁，将集合中<code>key</code>为<code>child</code>的删除，解锁</li></ul><h4 id="3-5-timerCtx"><a href="#3-5-timerCtx" class="headerlink" title="3.5 timerCtx"></a>3.5 timerCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    cancelCtx</span><br><span class="line">    timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line"></span><br><span class="line">    deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>timerCtx</code>在<code>cancelCtx</code>的基础上，又做了一层封装，新增了一个<code>time.Timer</code>用于定时终止<code>context</code>，另外新增一个<code>deadline</code>用于记录过期时间</p><h5 id="3-5-1-Deadline方法"><a href="#3-5-1-Deadline方法" class="headerlink" title="3.5.1 Deadline方法"></a>3.5.1 Deadline方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> c.deadline, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回过期时间</p><h5 id="3-5-2-String方法"><a href="#3-5-2-String方法" class="headerlink" title="3.5.2 String方法"></a>3.5.2 String方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> contextName(c.cancelCtx.Context) + <span class="string">&quot;.WithDeadline(&quot;</span> +</span><br><span class="line">        c.deadline.String() + <span class="string">&quot; [&quot;</span> +</span><br><span class="line">        time.Until(c.deadline).String() + <span class="string">&quot;])&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回<code>context</code>的名字加上过期时间</p><h5 id="3-5-3-cancel方法"><a href="#3-5-3-cancel方法" class="headerlink" title="3.5.3 cancel方法"></a>3.5.3 cancel方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err, cause <span class="type">error</span>) &#123;</span><br><span class="line">    c.cancelCtx.cancel(<span class="literal">false</span>, err, cause)</span><br><span class="line">    <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">        <span class="comment">// Remove this timerCtx from its parent cancelCtx&#x27;s children.</span></span><br><span class="line">        removeChild(c.cancelCtx.Context, c)</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.timer.Stop()</span><br><span class="line">        c.timer = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>继承<code>cancelCtx</code>的<code>cancel</code>方法，进行处理</li><li>判断是否需要从 <code>parent</code> 的 <code>children</code> 集合 中移除，若是则进行处理</li><li>加锁、停止<code>time.Timer</code>、解锁返回</li></ul><h4 id="3-6-valueCtx"><a href="#3-6-valueCtx" class="headerlink" title="3.6 valueCtx"></a>3.6 valueCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    Context</span><br><span class="line">    key, val any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>valueCtx</code>同样继承了<code>Context</code>，同时一个<code>valueCtx</code>只能存储一对<code>kv</code></p><h5 id="3-6-1-String方法"><a href="#3-6-1-String方法" class="headerlink" title="3.6.1 String方法"></a>3.6.1 String方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> contextName(c.Context) + <span class="string">&quot;.WithValue(type &quot;</span> +</span><br><span class="line">        reflectlite.TypeOf(c.key).String() +</span><br><span class="line">        <span class="string">&quot;, val &quot;</span> + stringify(c.val) + <span class="string">&quot;)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回<code>valueCtx</code>的名字以及存储的<code>kv</code>值</p><h5 id="3-6-2-Value方法"><a href="#3-6-2-Value方法" class="headerlink" title="3.6.2 Value方法"></a>3.6.2 Value方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">    <span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">        <span class="keyword">return</span> c.val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value(c.Context, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果参数的<code>key</code>等于他所保存的<code>key</code>则返回所保存的<code>value</code></li><li>否则去<code>parent</code>的<code>Context</code>去找</li></ul><p>进一步观察是如何在<code>parent</code>中寻找的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">value</span><span class="params">(c Context, key any)</span></span> any &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> ctx := c.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> *valueCtx:</span><br><span class="line">            <span class="keyword">if</span> key == ctx.key &#123;</span><br><span class="line">                <span class="keyword">return</span> ctx.val</span><br><span class="line">            &#125;</span><br><span class="line">            c = ctx.Context</span><br><span class="line">        <span class="keyword">case</span> *cancelCtx:</span><br><span class="line">            <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">                <span class="keyword">return</span> c</span><br><span class="line">            &#125;</span><br><span class="line">            c = ctx.Context</span><br><span class="line">        <span class="keyword">case</span> withoutCancelCtx:</span><br><span class="line">            <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">                <span class="comment">// This implements Cause(ctx) == nil</span></span><br><span class="line">                <span class="comment">// when ctx is created using WithoutCancel.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            c = ctx.c</span><br><span class="line">        <span class="keyword">case</span> *timerCtx:</span><br><span class="line">            <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">                <span class="keyword">return</span> &amp;ctx.cancelCtx</span><br><span class="line">            &#125;</span><br><span class="line">            c = ctx.Context</span><br><span class="line">        <span class="keyword">case</span> backgroundCtx, todoCtx:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> c.Value(key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动一个 for 循环，一直往上去父上下文中寻找</li><li>其中不同的上下文类型会有不同的处理方式；</li><li>找到匹配的 key，则将该value 进行返回.</li></ul><h3 id="4-创建context"><a href="#4-创建context" class="headerlink" title="4 创建context"></a>4 创建context</h3><h4 id="4-1-cancelCtx"><a href="#4-1-cancelCtx" class="headerlink" title="4.1 cancelCtx"></a>4.1 cancelCtx</h4><p>有两种方法，一个不带<code>cause</code>，一个带有<code>cause</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line">    c := withCancel(parent)</span><br><span class="line">    <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled, <span class="literal">nil</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancelCause</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelCauseFunc) &#123;</span><br><span class="line">    c := withCancel(parent)</span><br><span class="line">    <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">(cause <span class="type">error</span>)</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled, cause) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-withoutCancelCtx"><a href="#4-2-withoutCancelCtx" class="headerlink" title="4.2 withoutCancelCtx"></a>4.2 withoutCancelCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithoutCancel</span><span class="params">(parent Context)</span></span> Context &#123;</span><br><span class="line">    <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> withoutCancelCtx&#123;parent&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-Deadline"><a href="#4-3-Deadline" class="headerlink" title="4.3 Deadline"></a>4.3 Deadline</h4><p>同样有两种方法，一个不带<code>cause</code>，一个带有<code>cause</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line">    <span class="keyword">return</span> WithDeadlineCause(parent, d, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadlineCause</span><span class="params">(parent Context, d time.Time, cause <span class="type">error</span>)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line">    <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line">        <span class="comment">// The current deadline is already sooner than the new one.</span></span><br><span class="line">        <span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">    &#125;</span><br><span class="line">    c := &amp;timerCtx&#123;</span><br><span class="line">        deadline: d,</span><br><span class="line">    &#125;</span><br><span class="line">    c.cancelCtx.propagateCancel(parent, c)</span><br><span class="line">    dur := time.Until(d)</span><br><span class="line">    <span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        c.cancel(<span class="literal">true</span>, DeadlineExceeded, cause) <span class="comment">// deadline has already passed</span></span><br><span class="line">        <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">false</span>, Canceled, <span class="literal">nil</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    <span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">        c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            c.cancel(<span class="literal">true</span>, DeadlineExceeded, cause)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled, <span class="literal">nil</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-Timeout"><a href="#4-4-Timeout" class="headerlink" title="4.4 Timeout"></a>4.4 Timeout</h4><p>同样有两种方法，一个不带<code>cause</code>，一个带有<code>cause</code>，最后都是通过<code>WithDeadlineCause</code>来创建的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line">    <span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeoutCause</span><span class="params">(parent Context, timeout time.Duration, cause <span class="type">error</span>)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line">    <span class="keyword">return</span> WithDeadlineCause(parent, time.Now().Add(timeout), cause)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-ValueCtx"><a href="#4-5-ValueCtx" class="headerlink" title="4.5 ValueCtx"></a>4.5 ValueCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val any)</span></span> Context &#123;</span><br><span class="line">    <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;nil key&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;key is not comparable&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码解读 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
