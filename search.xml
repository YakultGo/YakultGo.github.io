<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Context源码解读</title>
      <link href="/posts/undefined.html"/>
      <url>/posts/undefined.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>特别提醒，本文所涉及的源码是<code>go1.21.0 darwin/amd64</code></p></blockquote><h3 id="1-什么是Context"><a href="#1-什么是Context" class="headerlink" title="1. 什么是Context"></a>1. 什么是Context</h3><p>在多个goroutine之间传递上下文的对象，传递的信息包括取消信号、截止时间以及其他一些跨api边界的值</p><h3 id="2-核心数据结构"><a href="#2-核心数据结构" class="headerlink" title="2. 核心数据结构"></a>2. 核心数据结构</h3><h4 id="2-1-Context"><a href="#2-1-Context" class="headerlink" title="2.1 Context"></a>2.1 Context</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">  Err() <span class="type">error</span></span><br><span class="line">Value(key any) any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Context</code>定义为<code>Interface</code>，定义了4个核心函数：</p><ul><li>Dealine：返回<code>context</code>的过期时间和一个<code>bool</code>值判断是否设置了deadline</li><li>Done：返回<code>context</code>中的<code>channel</code>，该<code>channel</code>会在当前工作完成或者上下文被取消后关闭，多次调用返回的是同一个<code>channel</code>，如果该<code>context</code>是不能被取消的，则会返回<code>nil</code></li><li>Err：返回<code>context</code>结束的原因</li><li>Value：返回<code>contxet</code>中存储的key对应的值</li></ul><h4 id="2-2-error"><a href="#2-2-error" class="headerlink" title="2.2 error"></a>2.2 error</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Canceled = errors.New(<span class="string">&quot;context canceled&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DeadlineExceeded <span class="type">error</span> = deadlineExceededError&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> deadlineExceededError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Error() <span class="type">string</span>   &#123; <span class="keyword">return</span> <span class="string">&quot;context deadline exceeded&quot;</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Timeout() <span class="type">bool</span>   &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Temporary() <span class="type">bool</span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><ul><li>Canceled：<code>context</code>被cancel时会返回该类错误</li><li>DeadlineExceeded：<code>context</code>超时时会返回该类错误</li></ul><h3 id="3-具体实现"><a href="#3-具体实现" class="headerlink" title="3 具体实现"></a>3 具体实现</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://mxshop-yakult.oss-cn-hangzhou.aliyuncs.com/img/image-20230823100804205.png" alt="image-20230823100804205" style="zoom: 33%;" /></h3><h4 id="3-1-emptyCtx"><a href="#3-1-emptyCtx" class="headerlink" title="3.1 emptyCtx"></a>3.1 emptyCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(emptyCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(emptyCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(emptyCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(emptyCtx)</span></span> Value(key any) any &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>emptyCtx</code>是一个空的<code>context</code>，之前的一些版本中是直接将它定义为一个<code>int</code>类型</p><h4 id="3-2-backgroundCtx"><a href="#3-2-backgroundCtx" class="headerlink" title="3.2 backgroundCtx"></a>3.2 backgroundCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> backgroundCtx <span class="keyword">struct</span>&#123; emptyCtx &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(backgroundCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;context.Background&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span></span> Context &#123;</span><br><span class="line"><span class="keyword">return</span> backgroundCtx&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Background()</code>返回一个非nil但是为空的<code>context</code>。它不能被取消，没有任何值，也没有截止时间。通常被主函数、初始化、测试以及作为传入请求的顶层<code>context</code>使用。</p><h4 id="3-3-todoCtx"><a href="#3-3-todoCtx" class="headerlink" title="3.3 todoCtx"></a>3.3 todoCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> todoCtx <span class="keyword">struct</span>&#123; emptyCtx &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(todoCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;context.TODO&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span></span> Context &#123;</span><br><span class="line"><span class="keyword">return</span> todoCtx&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TODO()</code>同样返回一个非nil但是为空的<code>context</code>。在代码不清楚应该使用哪个上下文或者上下文尚不可用时，应该使用<code>context.TODO</code></p><h4 id="3-4-cancelCtx"><a href="#3-4-cancelCtx" class="headerlink" title="3.4 cancelCtx"></a>3.4 cancelCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">Context</span><br><span class="line"></span><br><span class="line">mu       sync.Mutex            <span class="comment">// protects following fields</span></span><br><span class="line">done     atomic.Value          <span class="comment">// of chan struct&#123;&#125;, created lazily, closed by first cancel call</span></span><br><span class="line">children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">err      <span class="type">error</span>                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">cause    <span class="type">error</span>                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cancelCtx</code>是取消机制的关键</p><ul><li><p>其结构体嵌入了一个&#96;Context，作为其父类</p></li><li><p>mu：内置一把锁，用于多goroutine并发场景下的资源获取</p></li><li><p>done：原子类型的值，实际类型为<code>chan struct&#123;&#125;</code>，用来反应<code>cancelCtx</code>的生命周期</p></li><li><p>children：一个集合，保存了所有该<code>cancelCtx</code>的子<code>context</code></p></li><li><p>err：记录<code>cancelCtx</code>发生的错误</p></li><li><p>cause：记录<code>calcelCtx</code>被取消的原因</p></li></ul><h5 id="3-4-1-Value方法"><a href="#3-4-1-Value方法" class="headerlink" title="3.4.1 Value方法"></a>3.4.1 Value方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &amp;cancelCtxKey is the key that a cancelCtx returns itself for.</span></span><br><span class="line"><span class="keyword">var</span> cancelCtxKey <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Value(key any) any &#123;</span><br><span class="line"><span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> value(c.Context, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>key</code>的值为<code>&amp;cancelCtxKey</code>，则返回<code>cancelCtx</code>本身的指针，否则返回对应<code>key</code>存储的<code>value</code>值</p><h5 id="3-4-2-Done方法"><a href="#3-4-2-Done方法" class="headerlink" title="3.4.2 Done方法"></a>3.4.2 Done方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">d := c.done.Load()</span><br><span class="line"><span class="keyword">if</span> d != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> d.(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">d = c.done.Load()</span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">d = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">c.done.Store(d)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d.(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>前面提到<code>done</code>属性是一个原子类型的值,因此通过<code>atomic</code>包中的<code>Load()</code>函数获取它的值,如果它已经存在则直接返回</li><li>如果不存在则先加锁，然后创建一个新的<code>chan struct&#123;&#125;</code>，然后通过<code>Store()</code>赋值给<code>done</code>，可以看到这是一个懒加载机制，在第一次调用<code>c.Done()</code>的时候，该属性才被创建，返回值，然后解锁</li></ul><h5 id="3-4-3-Err方法"><a href="#3-4-3-Err方法" class="headerlink" title="3.4.3 Err方法"></a>3.4.3 Err方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line">err := c.err</span><br><span class="line">c.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加锁、读取值、解锁、返回结果</p><h5 id="3-4-4-propagateCancel方法"><a href="#3-4-4-propagateCancel方法" class="headerlink" title="3.4.4 propagateCancel方法"></a>3.4.4 propagateCancel方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> propagateCancel(parent Context, child canceler) &#123;</span><br><span class="line">c.Context = parent</span><br><span class="line"></span><br><span class="line">done := parent.Done()</span><br><span class="line"><span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="comment">// parent is already canceled</span></span><br><span class="line">child.cancel(<span class="literal">false</span>, parent.Err(), Cause(parent))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line"><span class="comment">// parent is a *cancelCtx, or derives from one.</span></span><br><span class="line">p.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// parent has already been canceled</span></span><br><span class="line">child.cancel(<span class="literal">false</span>, p.err, p.cause)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">p.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a, ok := parent.(afterFuncer); ok &#123;</span><br><span class="line"><span class="comment">// parent implements an AfterFunc method.</span></span><br><span class="line">c.mu.Lock()</span><br><span class="line">stop := a.AfterFunc(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">child.cancel(<span class="literal">false</span>, parent.Err(), Cause(parent))</span><br><span class="line">&#125;)</span><br><span class="line">c.Context = stopCtx&#123;</span><br><span class="line">Context: parent,</span><br><span class="line">stop:    stop,</span><br><span class="line">&#125;</span><br><span class="line">c.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goroutines.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">child.cancel(<span class="literal">false</span>, parent.Err(), Cause(parent))</span><br><span class="line"><span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法比较关键，会构建父子上下文之间的关联，当父上下文被取消时，子上下文也会被取消，不会出现状态不一致的情况</p><ul><li>首先将<code>parent</code>赋值给<code>Context</code>属性</li><li>如果父上下文不会取消，则直接返回</li><li>如果父上下文已经取消，则直接终止子上下文</li><li>如果父上下文是可以取消的上下文类型，即<code>cancelCtx</code>，则先加锁、然后将其加入到父上下文的<code>children</code>中，最后解锁</li><li>如果父上下文实现了<code>AfterFunc</code>方法，则在上下文被取消后，将子上下文也取消，通过调用一个<code>stop()</code>函数来实现的</li><li>如果都没满足前面的条件，则启动一个协程监控parent状态，倘若父上下文终止，则终止子上下文</li></ul><blockquote><p>进一步观察<code>parentCancelCtx</code>是如何校验<code>parent</code>是否为<code>cancelCtx</code>类型的</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> closedchan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">close</span>(closedchan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span></span> (*cancelCtx, <span class="type">bool</span>) &#123;</span><br><span class="line">done := parent.Done()</span><br><span class="line"><span class="keyword">if</span> done == closedchan || done == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">p, ok := parent.Value(&amp;cancelCtxKey).(*cancelCtx)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">pdone, _ := p.done.Load().(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> pdone != done &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>closedchan</code>表示一个已经关闭的通道</li><li>倘若<code>parent</code>的<code>channel</code>已经被关闭或者是不会被<code>cancel</code>的类型，则直接返回<code>false</code></li><li>倘若用<code>&amp;cancelCtxKey</code>能取到值并且得到的值是<code>parent</code>本身,返回<code>true</code>（<code>cancelCtx</code>的约定，<code>key</code>为<code>&amp;cancelCtxKey</code>的时候，返回的是<code>cancelCtx</code>本身的指针）</li></ul><h5 id="3-4-5-String方法"><a href="#3-4-5-String方法" class="headerlink" title="3.4.5 String方法"></a>3.4.5 String方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> contextName(c.Context) + <span class="string">&quot;.WithCancel&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回<code>cancelCtx</code>的名字</p><h5 id="3-4-6-cancel方法"><a href="#3-4-6-cancel方法" class="headerlink" title="3.4.6 cancel方法"></a>3.4.6 cancel方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err, cause <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;context: internal error: missing cancel error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> cause == <span class="literal">nil</span> &#123;</span><br><span class="line">cause = err</span><br><span class="line">&#125;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// already canceled</span></span><br><span class="line">&#125;</span><br><span class="line">c.err = err</span><br><span class="line">c.cause = cause</span><br><span class="line">d, _ := c.done.Load().(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">c.done.Store(closedchan)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">close</span>(d)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> acquiring the child&#x27;s lock while holding parent&#x27;s lock.</span></span><br><span class="line">child.cancel(<span class="literal">false</span>, err, cause)</span><br><span class="line">&#125;</span><br><span class="line">c.children = <span class="literal">nil</span></span><br><span class="line">c.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">removeChild(c.Context, c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>该方法接收三个参数，<code>removeFromParent</code>是一个<code>bool</code>值，表示需要从当前<code>context</code>的父<code>context</code>的<code>children</code>中删除</li><li>加锁，判断自己的<code>err</code>是否为空，如果不为空，说明已经被<code>cancel</code>，直接返回</li><li>处理 <code>cancelCtx</code> 的 <code>channel</code>，若<code> channel</code> 此前未初始化，则直接注入一个 <code>closedChan</code>，否则关闭该 <code>channel</code></li><li>遍历该<code>cancelCtx</code>的子<code>context</code>，依次将其<code>cancel</code></li><li>解锁，最后根据传入的参数<code>removeFromParent</code>，判断是否需要手动把 <code>cancelCtx</code> 从 <code>parent</code> 的<code> children</code> 集合中移除</li></ul><blockquote><p>走进 <code>removeChild</code> 方法中，观察如何将 <code>cancelCtx</code> 从<code> parent</code> 的<code> children</code> 集合 中移除：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeChild</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> s, ok := parent.(stopCtx); ok &#123;</span><br><span class="line">s.stop()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">p, ok := parentCancelCtx(parent)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">p.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> p.children != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(p.children, child)</span><br><span class="line">&#125;</span><br><span class="line">p.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果<code>parent</code>不是<code>cancelCtx</code>类型的，则直接返回（因为只有 <code>cancelCtx</code> 才有 <code>children</code>集合）</li><li>加锁，将集合中<code>key</code>为<code>child</code>的删除，解锁</li></ul><h4 id="3-5-timerCtx"><a href="#3-5-timerCtx" class="headerlink" title="3.5 timerCtx"></a>3.5 timerCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">cancelCtx</span><br><span class="line">timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line"></span><br><span class="line">deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>timerCtx</code>在<code>cancelCtx</code>的基础上，又做了一层封装，新增了一个<code>time.Timer</code>用于定时终止<code>context</code>，另外新增一个<code>deadline</code>用于记录过期时间</p><h5 id="3-5-1-Deadline方法"><a href="#3-5-1-Deadline方法" class="headerlink" title="3.5.1 Deadline方法"></a>3.5.1 Deadline方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> c.deadline, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回过期时间</p><h5 id="3-5-2-String方法"><a href="#3-5-2-String方法" class="headerlink" title="3.5.2 String方法"></a>3.5.2 String方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> contextName(c.cancelCtx.Context) + <span class="string">&quot;.WithDeadline(&quot;</span> +</span><br><span class="line">c.deadline.String() + <span class="string">&quot; [&quot;</span> +</span><br><span class="line">time.Until(c.deadline).String() + <span class="string">&quot;])&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回<code>context</code>的名字加上过期时间</p><h5 id="3-5-3-cancel方法"><a href="#3-5-3-cancel方法" class="headerlink" title="3.5.3 cancel方法"></a>3.5.3 cancel方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err, cause <span class="type">error</span>) &#123;</span><br><span class="line">c.cancelCtx.cancel(<span class="literal">false</span>, err, cause)</span><br><span class="line"><span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line"><span class="comment">// Remove this timerCtx from its parent cancelCtx&#x27;s children.</span></span><br><span class="line">removeChild(c.cancelCtx.Context, c)</span><br><span class="line">&#125;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">c.timer.Stop()</span><br><span class="line">c.timer = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>继承<code>cancelCtx</code>的<code>cancel</code>方法，进行处理</li><li>判断是否需要从 <code>parent</code> 的 <code>children</code> 集合 中移除，若是则进行处理</li><li>加锁、停止<code>time.Timer</code>、解锁返回</li></ul><h4 id="3-6-valueCtx"><a href="#3-6-valueCtx" class="headerlink" title="3.6 valueCtx"></a>3.6 valueCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">Context</span><br><span class="line">key, val any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>valueCtx</code>同样继承了<code>Context</code>，同时一个<code>valueCtx</code>只能存储一对<code>kv</code></p><h5 id="3-6-1-String方法"><a href="#3-6-1-String方法" class="headerlink" title="3.6.1 String方法"></a>3.6.1 String方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> contextName(c.Context) + <span class="string">&quot;.WithValue(type &quot;</span> +</span><br><span class="line">reflectlite.TypeOf(c.key).String() +</span><br><span class="line"><span class="string">&quot;, val &quot;</span> + stringify(c.val) + <span class="string">&quot;)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回<code>valueCtx</code>的名字以及存储的<code>kv</code>值</p><h5 id="3-6-2-Value方法"><a href="#3-6-2-Value方法" class="headerlink" title="3.6.2 Value方法"></a>3.6.2 Value方法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> Value(key any) any &#123;</span><br><span class="line"><span class="keyword">if</span> c.key == key &#123;</span><br><span class="line"><span class="keyword">return</span> c.val</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> value(c.Context, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果参数的<code>key</code>等于他所保存的<code>key</code>则返回所保存的<code>value</code></li><li>否则去<code>parent</code>的<code>Context</code>去找</li></ul><p>进一步观察是如何在<code>parent</code>中寻找的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">value</span><span class="params">(c Context, key any)</span></span> any &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> ctx := c.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *valueCtx:</span><br><span class="line"><span class="keyword">if</span> key == ctx.key &#123;</span><br><span class="line"><span class="keyword">return</span> ctx.val</span><br><span class="line">&#125;</span><br><span class="line">c = ctx.Context</span><br><span class="line"><span class="keyword">case</span> *cancelCtx:</span><br><span class="line"><span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line">c = ctx.Context</span><br><span class="line"><span class="keyword">case</span> withoutCancelCtx:</span><br><span class="line"><span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line"><span class="comment">// This implements Cause(ctx) == nil</span></span><br><span class="line"><span class="comment">// when ctx is created using WithoutCancel.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">c = ctx.c</span><br><span class="line"><span class="keyword">case</span> *timerCtx:</span><br><span class="line"><span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;ctx.cancelCtx</span><br><span class="line">&#125;</span><br><span class="line">c = ctx.Context</span><br><span class="line"><span class="keyword">case</span> backgroundCtx, todoCtx:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> c.Value(key)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动一个 for 循环，一直往上去父上下文中寻找</li><li>其中不同的上下文类型会有不同的处理方式；</li><li>找到匹配的 key，则将该value 进行返回.</li></ul>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码解读 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
